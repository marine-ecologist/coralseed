{"version":3,"file":"uri-utils.js","sourceRoot":"","sources":["../../../src/parser/uri-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { alphaNumericAndMarksRe, letterRe, digitRe } from '../regex-lib';\nimport { tldRegex } from './tld-regex';\n\n/**\n * A regular expression that is simply the character class of the characters\n * that may be used in a domain name, minus the '-' or '.'\n */\nexport const domainNameCharRegex = alphaNumericAndMarksRe;\n\n/**\n * The set of characters that will start a URL suffix (i.e. the path, query, and\n * hash part of the URL)\n */\nexport const urlSuffixStartCharsRe = /[\\/?#]/;\n\n/**\n * The set of characters that are allowed in the URL suffix (i.e. the path,\n * query, and hash part of the URL) which may also form the ending character of\n * the URL.\n *\n * The {@link #urlSuffixNotAllowedAsLastCharRe} are additional allowed URL\n * suffix characters, but (generally) should not be the last character of a URL.\n */\nexport const urlSuffixAllowedSpecialCharsRe = /[-+&@#/%=~_()|'$*\\[\\]{}\\u2713]/;\n\n/**\n * URL suffix characters (i.e. path, query, and has part of the URL) that are\n * not allowed as the *last character* in the URL suffix as they would normally\n * form the end of a sentence.\n *\n * The {@link #urlSuffixAllowedSpecialCharsRe} contains additional allowed URL\n * suffix characters which are allowed as the last character.\n */\nexport const urlSuffixNotAllowedAsLastCharRe = /[?!:,.;^]/;\n\n/**\n * Regular expression to match an http:// or https:// scheme.\n */\nexport const httpSchemeRe = /https?:\\/\\//i;\n\n/**\n * Regular expression to match an http:// or https:// scheme as the prefix of\n * a string.\n */\nexport const httpSchemePrefixRe = new RegExp('^' + httpSchemeRe.source, 'i');\n\nexport const urlSuffixedCharsNotAllowedAtEndRe = new RegExp(\n    urlSuffixNotAllowedAsLastCharRe.source + '$'\n);\n\n/**\n * A regular expression used to determine the schemes we should not autolink\n */\nexport const invalidSchemeRe = /^(javascript|vbscript):/i;\n\n// A regular expression used to determine if the URL is a scheme match (such as\n// 'http://google.com', and as opposed to a \"TLD match\"). This regular\n// expression is used to parse out the host along with if the URL has an\n// authority component (i.e. '//')\n//\n// Capturing groups:\n//    1. '//' if the URL has an authority component, empty string otherwise\n//    2. The host (if one exists). Ex: 'google.com'\n//\n// See https://www.rfc-editor.org/rfc/rfc3986#appendix-A for terminology\nexport const schemeUrlRe = /^[A-Za-z][-.+A-Za-z0-9]*:(\\/\\/)?([^:/]*)/;\n\n// A regular expression used to determine if the URL is a TLD match (such as\n// 'google.com', and as opposed to a \"scheme match\"). This regular\n// expression is used to help parse out the TLD (top-level domain) of the host.\n//\n// See https://www.rfc-editor.org/rfc/rfc3986#appendix-A for terminology\nexport const tldUrlHostRe = /^(?:\\/\\/)?([^/#?:]+)/; // optionally prefixed with protocol-relative '//' chars\n\n/**\n * Determines if the given character may start a scheme (ex: 'http').\n */\nexport function isSchemeStartChar(char: string): boolean {\n    return letterRe.test(char);\n}\n\n/**\n * Determines if the given character is a valid character in a scheme (such as\n * 'http' or 'ssh+git'), but only after the start char (which is handled by\n * {@link isSchemeStartChar}.\n */\nexport function isSchemeChar(char: string): boolean {\n    return (\n        letterRe.test(char) || digitRe.test(char) || char === '+' || char === '-' || char === '.'\n    );\n}\n\n/**\n * Determines if the character can begin a domain label, which must be an\n * alphanumeric character and not an underscore or dash.\n *\n * A domain label is a segment of a hostname such as subdomain.google.com.\n */\nexport function isDomainLabelStartChar(char: string): boolean {\n    return alphaNumericAndMarksRe.test(char);\n}\n\n/**\n * Determines if the character is part of a domain label (but not a domain label\n * start character).\n *\n * A domain label is a segment of a hostname such as subdomain.google.com.\n */\nexport function isDomainLabelChar(char: string): boolean {\n    return char === '_' || isDomainLabelStartChar(char);\n}\n\n/**\n * Determines if the character is a path character (\"pchar\") as defined by\n * https://tools.ietf.org/html/rfc3986#appendix-A\n *\n *     pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *\n *     unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *     pct-encoded   = \"%\" HEXDIG HEXDIG\n *     sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                   / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n *\n * Note that this implementation doesn't follow the spec exactly, but rather\n * follows URL path characters found out in the wild (spec might be out of date?)\n */\nexport function isPathChar(char: string): boolean {\n    return (\n        alphaNumericAndMarksRe.test(char) ||\n        urlSuffixAllowedSpecialCharsRe.test(char) ||\n        urlSuffixNotAllowedAsLastCharRe.test(char)\n    );\n}\n\n/**\n * Determines if the character given may begin the \"URL Suffix\" section of a\n * URI (i.e. the path, query, or hash section). These are the '/', '?' and '#'\n * characters.\n *\n * See https://tools.ietf.org/html/rfc3986#appendix-A\n */\nexport function isUrlSuffixStartChar(char: string) {\n    return urlSuffixStartCharsRe.test(char);\n}\n\n/**\n * Determines if the TLD read in the host is a known TLD (Top-Level Domain).\n *\n * Example: 'com' would be a known TLD (for a host of 'google.com'), but\n * 'local' would not (for a domain name of 'my-computer.local').\n */\nexport function isKnownTld(tld: string) {\n    return tldRegex.test(tld.toLowerCase()); // make sure the tld is lowercase for the regex\n}\n\n/**\n * Determines if the given `url` is a valid scheme-prefixed URL.\n */\nexport function isValidSchemeUrl(url: string): boolean {\n    // If the scheme is 'javascript:' or 'vbscript:', these link\n    // types can be dangerous. Don't link them.\n    if (invalidSchemeRe.test(url)) {\n        return false;\n    }\n\n    const schemeMatch = url.match(schemeUrlRe);\n    if (!schemeMatch) {\n        return false;\n    }\n\n    const isAuthorityMatch = !!schemeMatch![1];\n    const host = schemeMatch![2];\n    if (isAuthorityMatch) {\n        // Any match that has an authority ('//' chars) after the scheme is\n        // valid, such as 'http://anything'\n        return true;\n    }\n\n    // If there's no authority ('//' chars), check that we have a hostname\n    // that looks valid.\n    //\n    // The host must contain at least one '.' char and have a domain label\n    // with at least one letter to be considered valid.\n    //\n    // Accept:\n    //   - git:domain.com (scheme followed by a host\n    // Do not accept:\n    //   - git:something ('something' doesn't look like a host)\n    //   - version:1.0   ('1.0' doesn't look like a host)\n    if (host.indexOf('.') === -1 || !letterRe.test(host)) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Determines if the given `url` is a match with a valid TLD.\n */\nexport function isValidTldMatch(url: string): boolean {\n    // TLD URL such as 'google.com', we need to confirm that we have a valid\n    // top-level domain\n    const tldUrlHostMatch = url.match(tldUrlHostRe);\n    if (!tldUrlHostMatch) {\n        // At this point, if the URL didn't match our TLD re, it must be invalid\n        // (highly unlikely to happen, but just in case)\n        return false;\n    }\n\n    const host = tldUrlHostMatch[0];\n    const hostLabels = host.split('.');\n    if (hostLabels.length < 2) {\n        // 0 or 1 host label, there's no TLD. Ex: 'localhost'\n        return false;\n    }\n\n    const tld = hostLabels[hostLabels.length - 1];\n    if (!isKnownTld(tld)) {\n        return false;\n    }\n\n    // TODO: Implement these conditions for TLD matcher:\n    // (\n    //     this.longestDomainLabelLength <= 63 &&\n    //     this.domainNameLength <= 255\n    // );\n\n    return true;\n}\n\n// Regular expression to confirm a valid IPv4 address (ex: '192.168.0.1')\nconst ipV4Re =\n    /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n\n// Regular expression used to split the IPv4 address itself from any port/path/query/hash\nconst ipV4PartRe = /[:/?#]/;\n\n/**\n * Determines if the given URL is a valid IPv4-prefixed URL.\n */\nexport function isValidIpV4Address(url: string): boolean {\n    // Grab just the IP address\n    const ipV4Part = url.split(ipV4PartRe, 1)[0]; // only 1 result needed\n\n    return ipV4Re.test(ipV4Part);\n}\n"]}