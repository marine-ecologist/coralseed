{"version":3,"file":"hashtag-match.js","sourceRoot":"","sources":["../../../src/match/hashtag-match.ts"],"names":[],"mappings":";;;;AACA,kCAAuC;AACvC,mDAAsE;AAEtE;;;;;;;;;GASG;AACH;IAAkC,wCAAa;IA0B3C;;;;OAIG;IACH,sBAAY,GAAuB;QAC/B,YAAA,MAAK,YAAC,GAAG,CAAC,SAAC;QA/Bf;;;;;;;WAOG;QACa,UAAI,GAAc,SAAS,CAAC;QAE5C;;;;;WAKG;QACc,iBAAW,GAAmB,SAAS,CAAC,CAAC,gGAAgG;QAE1J;;;;WAIG;QACc,aAAO,GAAW,EAAE,CAAC,CAAC,gGAAgG;QAUnI,KAAI,CAAC,WAAW,GAAG,GAAG,CAAC,WAAW,CAAC;QACnC,KAAI,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC;;IAC/B,CAAC;IAED;;;;;OAKG;IACH,8BAAO,GAAP;QACI,OAAO,SAAS,CAAC;IACrB,CAAC;IAED;;;;;OAKG;IACH,qCAAc,GAAd;QACI,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED;;;;OAIG;IACH,iCAAU,GAAV;QACI,OAAO,IAAI,CAAC,OAAO,CAAC;IACxB,CAAC;IAED;;;;OAIG;IACH,oCAAa,GAAb;QACI,IAAI,WAAW,GAAG,IAAI,CAAC,WAAW,EAC9B,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAE3B,QAAQ,WAAW,EAAE,CAAC;YAClB,KAAK,SAAS;gBACV,OAAO,8BAA8B,GAAG,OAAO,CAAC;YACpD,KAAK,UAAU;gBACX,OAAO,mCAAmC,GAAG,OAAO,CAAC;YACzD,KAAK,WAAW;gBACZ,OAAO,qCAAqC,GAAG,OAAO,CAAC;YAC3D,KAAK,QAAQ;gBACT,OAAO,6BAA6B,GAAG,OAAO,CAAC;YACnD,KAAK,SAAS;gBACV,OAAO,8BAA8B,GAAG,OAAO,CAAC;YAEpD;gBACI,sGAAsG;gBACtG,IAAA,mBAAW,EAAC,WAAW,CAAC,CAAC;gBACzB,MAAM,IAAI,KAAK,CAAC,mCAA4B,WAAW,CAAE,CAAC,CAAC;QACnE,CAAC;IACL,CAAC;IAED;;;;OAIG;IACH,oCAAa,GAAb;QACI,OAAO,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC;IAC9B,CAAC;IAED;;;;;;OAMG;IACH,0CAAmB,GAAnB;QACI,IAAI,gBAAgB,GAAG,gBAAK,CAAC,mBAAmB,WAAE,EAC9C,WAAW,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QAExC,IAAI,WAAW,EAAE,CAAC;YACd,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACvC,CAAC;QACD,OAAO,gBAAgB,CAAC;IAC5B,CAAC;IACL,mBAAC;AAAD,CAAC,AAxHD,CAAkC,8BAAa,GAwH9C;AAxHY,oCAAY","sourcesContent":["import { HashtagService } from '../parser/hashtag-utils';\nimport { assertNever } from '../utils';\nimport { AbstractMatch, AbstractMatchConfig } from './abstract-match';\n\n/**\n * @class Autolinker.match.Hashtag\n * @extends Autolinker.match.AbstractMatch\n *\n * Represents a Hashtag match found in an input string which should be\n * Autolinked.\n *\n * See this class's superclass ({@link Autolinker.match.Match}) for more\n * details.\n */\nexport class HashtagMatch extends AbstractMatch {\n    /**\n     * @public\n     * @property {'hashtag'} type\n     *\n     * A string name for the type of match that this class represents. Can be\n     * used in a TypeScript discriminating union to type-narrow from the\n     * `Match` type.\n     */\n    public readonly type: 'hashtag' = 'hashtag';\n\n    /**\n     * @cfg {String} serviceName\n     *\n     * The service to point hashtag matches to. See {@link Autolinker#hashtag}\n     * for available values.\n     */\n    private readonly serviceName: HashtagService = 'twitter'; // default value just to get the above doc comment in the ES5 output and documentation generator\n\n    /**\n     * @cfg {String} hashtag (required)\n     *\n     * The HashtagMatch that was matched, without the '#'.\n     */\n    private readonly hashtag: string = ''; // default value just to get the above doc comment in the ES5 output and documentation generator\n\n    /**\n     * @method constructor\n     * @param {Object} cfg The configuration properties for the Match\n     *   instance, specified in an Object (map).\n     */\n    constructor(cfg: HashtagMatchConfig) {\n        super(cfg);\n\n        this.serviceName = cfg.serviceName;\n        this.hashtag = cfg.hashtag;\n    }\n\n    /**\n     * Returns a string name for the type of match that this class represents.\n     * For the case of HashtagMatch, returns 'hashtag'.\n     *\n     * @return {String}\n     */\n    getType(): 'hashtag' {\n        return 'hashtag';\n    }\n\n    /**\n     * Returns the configured {@link #serviceName} to point the HashtagMatch to.\n     * Ex: 'facebook', 'twitter'.\n     *\n     * @return {String}\n     */\n    getServiceName(): HashtagService {\n        return this.serviceName;\n    }\n\n    /**\n     * Returns the matched hashtag, without the '#' character.\n     *\n     * @return {String}\n     */\n    getHashtag(): string {\n        return this.hashtag;\n    }\n\n    /**\n     * Returns the anchor href that should be generated for the match.\n     *\n     * @return {String}\n     */\n    getAnchorHref(): string {\n        let serviceName = this.serviceName,\n            hashtag = this.hashtag;\n\n        switch (serviceName) {\n            case 'twitter':\n                return 'https://twitter.com/hashtag/' + hashtag;\n            case 'facebook':\n                return 'https://www.facebook.com/hashtag/' + hashtag;\n            case 'instagram':\n                return 'https://instagram.com/explore/tags/' + hashtag;\n            case 'tiktok':\n                return 'https://www.tiktok.com/tag/' + hashtag;\n            case 'youtube':\n                return 'https://youtube.com/hashtag/' + hashtag;\n\n            default:\n                // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case\n                assertNever(serviceName);\n                throw new Error(`Invalid hashtag service: ${serviceName}`);\n        }\n    }\n\n    /**\n     * Returns the anchor text that should be generated for the match.\n     *\n     * @return {String}\n     */\n    getAnchorText(): string {\n        return '#' + this.hashtag;\n    }\n\n    /**\n     * Returns the CSS class suffixes that should be used on a tag built with\n     * the match. See {@link Autolinker.match.Match#getCssClassSuffixes} for\n     * details.\n     *\n     * @return {String[]}\n     */\n    getCssClassSuffixes(): string[] {\n        let cssClassSuffixes = super.getCssClassSuffixes(),\n            serviceName = this.getServiceName();\n\n        if (serviceName) {\n            cssClassSuffixes.push(serviceName);\n        }\n        return cssClassSuffixes;\n    }\n}\n\nexport interface HashtagMatchConfig extends AbstractMatchConfig {\n    serviceName: HashtagService;\n    hashtag: string;\n}\n"]}