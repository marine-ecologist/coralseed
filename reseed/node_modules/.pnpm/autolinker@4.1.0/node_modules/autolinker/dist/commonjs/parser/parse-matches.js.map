{"version":3,"file":"parse-matches.js","sourceRoot":"","sources":["../../../src/parser/parse-matches.ts"],"names":[],"mappings":"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","sourcesContent":["import { alphaNumericAndMarksRe, digitRe } from '../regex-lib';\nimport { UrlMatch, UrlMatchType } from '../match/url-match';\nimport { Match } from '../match/match';\nimport { remove, assertNever } from '../utils';\nimport {\n    httpSchemeRe,\n    isDomainLabelChar,\n    isDomainLabelStartChar,\n    isPathChar,\n    isSchemeChar,\n    isSchemeStartChar,\n    isUrlSuffixStartChar,\n    isValidIpV4Address,\n    isValidSchemeUrl,\n    isValidTldMatch,\n    urlSuffixedCharsNotAllowedAtEndRe,\n} from './uri-utils';\nimport {\n    isEmailLocalPartChar,\n    isEmailLocalPartStartChar,\n    isValidEmail,\n    mailtoSchemePrefixRe,\n} from './email-utils';\nimport { EmailMatch } from '../match/email-match';\nimport { HashtagService, isHashtagTextChar, isValidHashtag } from './hashtag-utils';\nimport { HashtagMatch } from '../match/hashtag-match';\nimport { isMentionTextChar, isValidMention, MentionService } from './mention-utils';\nimport { MentionMatch } from '../match/mention-match';\nimport {\n    isPhoneNumberSeparatorChar,\n    isPhoneNumberControlChar,\n    isValidPhoneNumber,\n} from './phone-number-utils';\nimport { PhoneMatch } from '../match/phone-match';\nimport { AnchorTagBuilder } from '../anchor-tag-builder';\nimport type { StripPrefixConfigObj } from '../autolinker';\n\n// For debugging: search for and uncomment other \"For debugging\" lines\n// import CliTable from 'cli-table';\n\n/**\n * Parses URL, email, twitter, mention, and hashtag matches from the given\n * `text`.\n */\nexport function parseMatches(text: string, args: ParseMatchesArgs): Match[] {\n    const tagBuilder = args.tagBuilder;\n    const stripPrefix = args.stripPrefix;\n    const stripTrailingSlash = args.stripTrailingSlash;\n    const decodePercentEncoding = args.decodePercentEncoding;\n    const hashtagServiceName = args.hashtagServiceName;\n    const mentionServiceName = args.mentionServiceName;\n\n    const matches: Match[] = [];\n    const textLen = text.length;\n\n    // An array of all active state machines. Empty array means we're in the\n    // \"no url\" state\n    const stateMachines: StateMachine[] = [];\n\n    // For debugging: search for and uncomment other \"For debugging\" lines\n    // const table = new CliTable({\n    //     head: ['charIdx', 'char', 'code', 'type', 'states', 'charIdx', 'startIdx', 'reached accept state'],\n    // });\n\n    let charIdx = 0;\n    for (; charIdx < textLen; charIdx++) {\n        const char = text.charAt(charIdx);\n\n        if (stateMachines.length === 0) {\n            stateNoMatch(char);\n        } else {\n            // Must loop through the state machines backwards for when one\n            // is removed\n            for (let stateIdx = stateMachines.length - 1; stateIdx >= 0; stateIdx--) {\n                const stateMachine = stateMachines[stateIdx];\n\n                switch (stateMachine.state) {\n                    // Protocol-relative URL states\n                    case State.ProtocolRelativeSlash1:\n                        stateProtocolRelativeSlash1(stateMachine, char);\n                        break;\n                    case State.ProtocolRelativeSlash2:\n                        stateProtocolRelativeSlash2(stateMachine, char);\n                        break;\n\n                    case State.SchemeChar:\n                        stateSchemeChar(stateMachine, char);\n                        break;\n                    case State.SchemeHyphen:\n                        stateSchemeHyphen(stateMachine, char);\n                        break;\n                    case State.SchemeColon:\n                        stateSchemeColon(stateMachine, char);\n                        break;\n                    case State.SchemeSlash1:\n                        stateSchemeSlash1(stateMachine, char);\n                        break;\n                    case State.SchemeSlash2:\n                        stateSchemeSlash2(stateMachine, char);\n                        break;\n\n                    case State.DomainLabelChar:\n                        stateDomainLabelChar(stateMachine, char);\n                        break;\n                    case State.DomainHyphen:\n                        stateDomainHyphen(stateMachine, char);\n                        break;\n                    case State.DomainDot:\n                        stateDomainDot(stateMachine, char);\n                        break;\n\n                    case State.IpV4Digit:\n                        stateIpV4Digit(stateMachine as IpV4UrlStateMachine, char);\n                        break;\n                    case State.IpV4Dot:\n                        stateIPv4Dot(stateMachine as IpV4UrlStateMachine, char);\n                        break;\n\n                    case State.PortColon:\n                        statePortColon(stateMachine, char);\n                        break;\n                    case State.PortNumber:\n                        statePortNumber(stateMachine, char);\n                        break;\n                    case State.Path:\n                        statePath(stateMachine, char);\n                        break;\n\n                    // Email States\n                    case State.EmailMailto_M:\n                        stateEmailMailto_M(stateMachine, char);\n                        break;\n                    case State.EmailMailto_A:\n                        stateEmailMailto_A(stateMachine, char);\n                        break;\n                    case State.EmailMailto_I:\n                        stateEmailMailto_I(stateMachine, char);\n                        break;\n                    case State.EmailMailto_L:\n                        stateEmailMailto_L(stateMachine, char);\n                        break;\n                    case State.EmailMailto_T:\n                        stateEmailMailto_T(stateMachine, char);\n                        break;\n                    case State.EmailMailto_O:\n                        stateEmailMailto_O(stateMachine, char);\n                        break;\n                    case State.EmailMailto_Colon:\n                        stateEmailMailtoColon(stateMachine, char);\n                        break;\n                    case State.EmailLocalPart:\n                        stateEmailLocalPart(stateMachine, char);\n                        break;\n                    case State.EmailLocalPartDot:\n                        stateEmailLocalPartDot(stateMachine, char);\n                        break;\n                    case State.EmailAtSign:\n                        stateEmailAtSign(stateMachine, char);\n                        break;\n                    case State.EmailDomainChar:\n                        stateEmailDomainChar(stateMachine, char);\n                        break;\n                    case State.EmailDomainHyphen:\n                        stateEmailDomainHyphen(stateMachine, char);\n                        break;\n                    case State.EmailDomainDot:\n                        stateEmailDomainDot(stateMachine, char);\n                        break;\n\n                    // Hashtag states\n                    case State.HashtagHashChar:\n                        stateHashtagHashChar(stateMachine, char);\n                        break;\n                    case State.HashtagTextChar:\n                        stateHashtagTextChar(stateMachine, char);\n                        break;\n\n                    // Mention states\n                    case State.MentionAtChar:\n                        stateMentionAtChar(stateMachine, char);\n                        break;\n                    case State.MentionTextChar:\n                        stateMentionTextChar(stateMachine, char);\n                        break;\n\n                    // Phone number states\n                    case State.PhoneNumberOpenParen:\n                        statePhoneNumberOpenParen(stateMachine, char);\n                        break;\n                    case State.PhoneNumberAreaCodeDigit1:\n                        statePhoneNumberAreaCodeDigit1(stateMachine, char);\n                        break;\n                    case State.PhoneNumberAreaCodeDigit2:\n                        statePhoneNumberAreaCodeDigit2(stateMachine, char);\n                        break;\n                    case State.PhoneNumberAreaCodeDigit3:\n                        statePhoneNumberAreaCodeDigit3(stateMachine, char);\n                        break;\n                    case State.PhoneNumberCloseParen:\n                        statePhoneNumberCloseParen(stateMachine, char);\n                        break;\n                    case State.PhoneNumberPlus:\n                        statePhoneNumberPlus(stateMachine, char);\n                        break;\n                    case State.PhoneNumberDigit:\n                        statePhoneNumberDigit(stateMachine, char);\n                        break;\n                    case State.PhoneNumberSeparator:\n                        statePhoneNumberSeparator(stateMachine, char);\n                        break;\n                    case State.PhoneNumberControlChar:\n                        statePhoneNumberControlChar(stateMachine, char);\n                        break;\n                    case State.PhoneNumberPoundChar:\n                        statePhoneNumberPoundChar(stateMachine, char);\n                        break;\n\n                    default:\n                        assertNever(stateMachine.state);\n                }\n            }\n\n            // Special case for handling a colon (or other non-alphanumeric)\n            // when preceded by another character, such as in the text:\n            //     Link 1:http://google.com\n            // In this case, the 'h' character after the colon wouldn't start a\n            // new scheme url because we'd be in a ipv4 or tld url and the colon\n            // would be interpreted as a port ':' char. Also, only start a new\n            // scheme url machine if there isn't currently one so we don't start\n            // new ones for colons inside a url\n            if (charIdx > 0 && isSchemeStartChar(char)) {\n                const prevChar = text.charAt(charIdx - 1);\n                if (!isSchemeStartChar(prevChar) && !stateMachines.some(isSchemeUrlStateMachine)) {\n                    stateMachines.push(createSchemeUrlStateMachine(charIdx, State.SchemeChar));\n                }\n            }\n        }\n\n        // For debugging: search for and uncomment other \"For debugging\" lines\n        // table.push([\n        //     charIdx,\n        //     char,\n        //     `10: ${char.charCodeAt(0)}\\n0x: ${char.charCodeAt(0).toString(16)}\\nU+${char.codePointAt(0)}`,\n        //     stateMachines.map(machine => `${machine.type}${'matchType' in machine ? ` (${machine.matchType})` : ''}`).join('\\n') || '(none)',\n        //     stateMachines.map(machine => State[machine.state]).join('\\n') || '(none)',\n        //     charIdx,\n        //     stateMachines.map(m => m.startIdx).join('\\n'),\n        //     stateMachines.map(m => m.acceptStateReached).join('\\n'),\n        // ]);\n    }\n\n    // Capture any valid match at the end of the string\n    // Note: this loop must happen in reverse because\n    // captureMatchIfValidAndRemove() removes state machines from the array\n    // and we'll end up skipping every other one if we remove while looping\n    // forward\n    for (let i = stateMachines.length - 1; i >= 0; i--) {\n        stateMachines.forEach(stateMachine => captureMatchIfValidAndRemove(stateMachine));\n    }\n\n    // For debugging: search for and uncomment other \"For debugging\" lines\n    // console.log(`\\nRead string:\\n  ${text}`);\n    // console.log(table.toString());\n\n    return matches;\n\n    // Handles the state when we're not in a URL/email/etc. (i.e. when no state machines exist)\n    function stateNoMatch(char: string) {\n        if (char === '#') {\n            // Hash char, start a Hashtag match\n            stateMachines.push(createHashtagStateMachine(charIdx, State.HashtagHashChar));\n        } else if (char === '@') {\n            // '@' char, start a Mention match\n            stateMachines.push(createMentionStateMachine(charIdx, State.MentionAtChar));\n        } else if (char === '/') {\n            // A slash could begin a protocol-relative URL\n            stateMachines.push(createTldUrlStateMachine(charIdx, State.ProtocolRelativeSlash1));\n        } else if (char === '+') {\n            // A '+' char can start a Phone number\n            stateMachines.push(createPhoneNumberStateMachine(charIdx, State.PhoneNumberPlus));\n        } else if (char === '(') {\n            stateMachines.push(createPhoneNumberStateMachine(charIdx, State.PhoneNumberOpenParen));\n        } else {\n            if (digitRe.test(char)) {\n                // A digit could start a phone number\n                stateMachines.push(createPhoneNumberStateMachine(charIdx, State.PhoneNumberDigit));\n\n                // A digit could start an IP address\n                stateMachines.push(createIpV4UrlStateMachine(charIdx, State.IpV4Digit));\n            }\n\n            if (isEmailLocalPartStartChar(char)) {\n                // Any email local part. An 'm' character in particular could\n                // start a 'mailto:' match\n                const startState =\n                    char.toLowerCase() === 'm' ? State.EmailMailto_M : State.EmailLocalPart;\n                stateMachines.push(createEmailStateMachine(charIdx, startState));\n            }\n\n            if (isSchemeStartChar(char)) {\n                // An uppercase or lowercase letter may start a scheme match\n                stateMachines.push(createSchemeUrlStateMachine(charIdx, State.SchemeChar));\n            }\n\n            if (alphaNumericAndMarksRe.test(char)) {\n                // A unicode alpha character or digit could start a domain name\n                // label for a TLD match\n                stateMachines.push(createTldUrlStateMachine(charIdx, State.DomainLabelChar));\n            }\n        }\n\n        // Anything else, remain in the \"non-url\" state by not creating any\n        // state machines\n    }\n\n    // Implements ABNF: ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    function stateSchemeChar(stateMachine: StateMachine, char: string) {\n        if (char === ':') {\n            stateMachine.state = State.SchemeColon;\n        } else if (char === '-') {\n            stateMachine.state = State.SchemeHyphen;\n        } else if (isSchemeChar(char)) {\n            // Stay in SchemeChar state\n        } else {\n            // Any other character, not a scheme\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    function stateSchemeHyphen(stateMachine: StateMachine, char: string) {\n        if (char === '-') {\n            // Stay in SchemeHyphen state\n            // TODO: Should a colon following a dash be counted as the end of the scheme?\n            // } else if (char === ':') {\n            //     stateMachine.state = State.SchemeColon;\n        } else if (char === '/') {\n            // Not a valid scheme match, but may be the start of a\n            // protocol-relative match (such as //google.com)\n            remove(stateMachines, stateMachine);\n            stateMachines.push(createTldUrlStateMachine(charIdx, State.ProtocolRelativeSlash1));\n        } else if (isSchemeChar(char)) {\n            stateMachine.state = State.SchemeChar;\n        } else {\n            // Any other character, not a scheme\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    function stateSchemeColon(stateMachine: StateMachine, char: string) {\n        if (char === '/') {\n            stateMachine.state = State.SchemeSlash1;\n        } else if (char === '.') {\n            // We've read something like 'hello:.' - don't capture\n            remove(stateMachines, stateMachine);\n        } else if (isDomainLabelStartChar(char)) {\n            stateMachine.state = State.DomainLabelChar;\n\n            // It's possible that we read an \"introduction\" piece of text,\n            // and the character after the current colon actually starts an\n            // actual scheme. An example of this is:\n            //     \"The link:http://google.com\"\n            // Hence, start a new machine to capture this match if so\n            if (isSchemeStartChar(char)) {\n                stateMachines.push(createSchemeUrlStateMachine(charIdx, State.SchemeChar));\n            }\n        } else {\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    function stateSchemeSlash1(stateMachine: StateMachine, char: string) {\n        if (char === '/') {\n            stateMachine.state = State.SchemeSlash2;\n        } else if (isPathChar(char)) {\n            stateMachine.state = State.Path;\n            stateMachine.acceptStateReached = true;\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    function stateSchemeSlash2(stateMachine: StateMachine, char: string) {\n        if (char === '/') {\n            // 3rd slash, must be an absolute path (path-absolute in the\n            // ABNF), such as in a file:///c:/windows/etc. See\n            // https://tools.ietf.org/html/rfc3986#appendix-A\n            stateMachine.state = State.Path;\n        } else if (isDomainLabelStartChar(char)) {\n            // start of \"authority\" section - see https://tools.ietf.org/html/rfc3986#appendix-A\n            stateMachine.state = State.DomainLabelChar;\n            stateMachine.acceptStateReached = true;\n        } else {\n            // not valid\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    // Handles reading a '/' from the NonUrl state\n    function stateProtocolRelativeSlash1(stateMachine: StateMachine, char: string) {\n        if (char === '/') {\n            stateMachine.state = State.ProtocolRelativeSlash2;\n        } else {\n            // Anything else, cannot be the start of a protocol-relative\n            // URL.\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    // Handles reading a second '/', which could start a protocol-relative URL\n    function stateProtocolRelativeSlash2(stateMachine: StateMachine, char: string) {\n        if (isDomainLabelStartChar(char)) {\n            stateMachine.state = State.DomainLabelChar;\n        } else {\n            // Anything else, not a URL\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    // Handles when we have read a domain label character\n    function stateDomainLabelChar(stateMachine: StateMachine, char: string) {\n        if (char === '.') {\n            stateMachine.state = State.DomainDot;\n        } else if (char === '-') {\n            stateMachine.state = State.DomainHyphen;\n        } else if (char === ':') {\n            // Beginning of a port number, end the domain name\n            stateMachine.state = State.PortColon;\n        } else if (isUrlSuffixStartChar(char)) {\n            // '/', '?', or '#'\n            stateMachine.state = State.Path;\n        } else if (isDomainLabelChar(char)) {\n            // Stay in the DomainLabelChar state\n        } else {\n            // Anything else, end the domain name\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    function stateDomainHyphen(stateMachine: StateMachine, char: string) {\n        if (char === '-') {\n            // Remain in the DomainHyphen state\n        } else if (char === '.') {\n            // Not valid to have a '-.' in a domain label\n            captureMatchIfValidAndRemove(stateMachine);\n        } else if (isDomainLabelStartChar(char)) {\n            stateMachine.state = State.DomainLabelChar;\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    function stateDomainDot(stateMachine: StateMachine, char: string) {\n        if (char === '.') {\n            // domain names cannot have multiple '.'s next to each other.\n            // It's possible we've already read a valid domain name though,\n            // and that the '..' sequence just forms an ellipsis at the end\n            // of a sentence\n            captureMatchIfValidAndRemove(stateMachine);\n        } else if (isDomainLabelStartChar(char)) {\n            stateMachine.state = State.DomainLabelChar;\n            stateMachine.acceptStateReached = true; // after hitting a dot, and then another domain label, we've reached an accept state\n        } else {\n            // Anything else, end the domain name\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    function stateIpV4Digit(stateMachine: IpV4UrlStateMachine, char: string) {\n        if (char === '.') {\n            stateMachine.state = State.IpV4Dot;\n        } else if (char === ':') {\n            // Beginning of a port number\n            stateMachine.state = State.PortColon;\n        } else if (digitRe.test(char)) {\n            // stay in the IPv4 digit state\n        } else if (isUrlSuffixStartChar(char)) {\n            stateMachine.state = State.Path;\n        } else if (alphaNumericAndMarksRe.test(char)) {\n            // If we hit an alpha character, must not be an IPv4\n            // Example of this: 1.2.3.4abc\n            remove(stateMachines, stateMachine);\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    function stateIPv4Dot(stateMachine: IpV4UrlStateMachine, char: string) {\n        if (digitRe.test(char)) {\n            stateMachine.octetsEncountered++;\n\n            // Once we have encountered 4 octets, it's *potentially* a valid\n            // IPv4 address. Our IPv4 regex will confirm the match later\n            // though to make sure each octet is in the 0-255 range, and\n            // there's exactly 4 octets (not 5 or more)\n            if (stateMachine.octetsEncountered === 4) {\n                stateMachine.acceptStateReached = true;\n            }\n\n            stateMachine.state = State.IpV4Digit;\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    function statePortColon(stateMachine: StateMachine, char: string) {\n        if (digitRe.test(char)) {\n            stateMachine.state = State.PortNumber;\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    function statePortNumber(stateMachine: StateMachine, char: string) {\n        if (digitRe.test(char)) {\n            // Stay in port number state\n        } else if (isUrlSuffixStartChar(char)) {\n            // '/', '?', or '#'\n            stateMachine.state = State.Path;\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    function statePath(stateMachine: StateMachine, char: string) {\n        if (isPathChar(char)) {\n            // Stay in the path state\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    // Handles if we're reading a 'mailto:' prefix on the string\n    function stateEmailMailto_M(stateMachine: StateMachine, char: string) {\n        if (char.toLowerCase() === 'a') {\n            stateMachine.state = State.EmailMailto_A;\n        } else {\n            stateEmailLocalPart(stateMachine, char);\n        }\n    }\n\n    function stateEmailMailto_A(stateMachine: StateMachine, char: string) {\n        if (char.toLowerCase() === 'i') {\n            stateMachine.state = State.EmailMailto_I;\n        } else {\n            stateEmailLocalPart(stateMachine, char);\n        }\n    }\n\n    function stateEmailMailto_I(stateMachine: StateMachine, char: string) {\n        if (char.toLowerCase() === 'l') {\n            stateMachine.state = State.EmailMailto_L;\n        } else {\n            stateEmailLocalPart(stateMachine, char);\n        }\n    }\n\n    function stateEmailMailto_L(stateMachine: StateMachine, char: string) {\n        if (char.toLowerCase() === 't') {\n            stateMachine.state = State.EmailMailto_T;\n        } else {\n            stateEmailLocalPart(stateMachine, char);\n        }\n    }\n\n    function stateEmailMailto_T(stateMachine: StateMachine, char: string) {\n        if (char.toLowerCase() === 'o') {\n            stateMachine.state = State.EmailMailto_O;\n        } else {\n            stateEmailLocalPart(stateMachine, char);\n        }\n    }\n\n    function stateEmailMailto_O(stateMachine: StateMachine, char: string) {\n        if (char.toLowerCase() === ':') {\n            stateMachine.state = State.EmailMailto_Colon;\n        } else {\n            stateEmailLocalPart(stateMachine, char);\n        }\n    }\n\n    function stateEmailMailtoColon(stateMachine: StateMachine, char: string) {\n        if (isEmailLocalPartChar(char)) {\n            stateMachine.state = State.EmailLocalPart;\n        } else {\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    // Handles the state when we're currently in the \"local part\" of an\n    // email address (as opposed to the \"domain part\")\n    function stateEmailLocalPart(stateMachine: StateMachine, char: string) {\n        if (char === '.') {\n            stateMachine.state = State.EmailLocalPartDot;\n        } else if (char === '@') {\n            stateMachine.state = State.EmailAtSign;\n        } else if (isEmailLocalPartChar(char)) {\n            // stay in the \"local part\" of the email address\n            // Note: because stateEmailLocalPart() is called from the\n            // 'mailto' states (when the 'mailto' prefix itself has been\n            // broken), make sure to set the state to EmailLocalPart\n            stateMachine.state = State.EmailLocalPart;\n        } else {\n            // not an email address character\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    // Handles the state where we've read\n    function stateEmailLocalPartDot(stateMachine: StateMachine, char: string) {\n        if (char === '.') {\n            // We read a second '.' in a row, not a valid email address\n            // local part\n            remove(stateMachines, stateMachine);\n        } else if (char === '@') {\n            // We read the '@' character immediately after a dot ('.'), not\n            // an email address\n            remove(stateMachines, stateMachine);\n        } else if (isEmailLocalPartChar(char)) {\n            stateMachine.state = State.EmailLocalPart;\n        } else {\n            // Anything else, not an email address\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    function stateEmailAtSign(stateMachine: StateMachine, char: string) {\n        if (isDomainLabelStartChar(char)) {\n            stateMachine.state = State.EmailDomainChar;\n        } else {\n            // Anything else, not an email address\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    function stateEmailDomainChar(stateMachine: StateMachine, char: string) {\n        if (char === '.') {\n            stateMachine.state = State.EmailDomainDot;\n        } else if (char === '-') {\n            stateMachine.state = State.EmailDomainHyphen;\n        } else if (isDomainLabelChar(char)) {\n            // Stay in the DomainChar state\n        } else {\n            // Anything else, we potentially matched if the criteria has\n            // been met\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    function stateEmailDomainHyphen(stateMachine: StateMachine, char: string) {\n        if (char === '-' || char === '.') {\n            // Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n            captureMatchIfValidAndRemove(stateMachine);\n        } else if (isDomainLabelChar(char)) {\n            stateMachine.state = State.EmailDomainChar;\n        } else {\n            // Anything else\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    function stateEmailDomainDot(stateMachine: StateMachine, char: string) {\n        if (char === '.' || char === '-') {\n            // not valid to have two dots (\"..\") or dot+hypen (\".-\")\n            captureMatchIfValidAndRemove(stateMachine);\n        } else if (isDomainLabelStartChar(char)) {\n            stateMachine.state = State.EmailDomainChar;\n\n            // After having read a '.' and then a valid domain character,\n            // we now know that the domain part of the email is valid, and\n            // we have found at least a partial EmailMatch (however, the\n            // email address may have additional characters from this point)\n            stateMachine.acceptStateReached = true;\n        } else {\n            // Anything else\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    // Handles the state when we've just encountered a '#' character\n    function stateHashtagHashChar(stateMachine: StateMachine, char: string) {\n        if (isHashtagTextChar(char)) {\n            // '#' char with valid hash text char following\n            stateMachine.state = State.HashtagTextChar;\n            stateMachine.acceptStateReached = true;\n        } else {\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    // Handles the state when we're currently in the hash tag's text chars\n    function stateHashtagTextChar(stateMachine: StateMachine, char: string) {\n        if (isHashtagTextChar(char)) {\n            // Continue reading characters in the HashtagText state\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    // Handles the state when we've just encountered a '@' character\n    function stateMentionAtChar(stateMachine: StateMachine, char: string) {\n        if (isMentionTextChar(char)) {\n            // '@' char with valid mention text char following\n            stateMachine.state = State.MentionTextChar;\n            stateMachine.acceptStateReached = true;\n        } else {\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    // Handles the state when we're currently in the mention's text chars\n    function stateMentionTextChar(stateMachine: StateMachine, char: string) {\n        if (isMentionTextChar(char)) {\n            // Continue reading characters in the HashtagText state\n        } else if (alphaNumericAndMarksRe.test(char)) {\n            // Char is invalid for a mention text char, not a valid match.\n            // Note that ascii alphanumeric chars are okay (which are tested\n            // in the previous 'if' statement, but others are not)\n            remove(stateMachines, stateMachine);\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    function statePhoneNumberPlus(stateMachine: StateMachine, char: string) {\n        if (digitRe.test(char)) {\n            stateMachine.state = State.PhoneNumberDigit;\n        } else {\n            remove(stateMachines, stateMachine);\n\n            // This character may start a new match. Add states for it\n            stateNoMatch(char);\n        }\n    }\n\n    function statePhoneNumberOpenParen(stateMachine: StateMachine, char: string) {\n        if (digitRe.test(char)) {\n            stateMachine.state = State.PhoneNumberAreaCodeDigit1;\n        } else {\n            remove(stateMachines, stateMachine);\n        }\n\n        // It's also possible that the paren was just an open brace for\n        // a piece of text. Start other machines\n        stateNoMatch(char);\n    }\n\n    function statePhoneNumberAreaCodeDigit1(stateMachine: StateMachine, char: string) {\n        if (digitRe.test(char)) {\n            stateMachine.state = State.PhoneNumberAreaCodeDigit2;\n        } else {\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    function statePhoneNumberAreaCodeDigit2(stateMachine: StateMachine, char: string) {\n        if (digitRe.test(char)) {\n            stateMachine.state = State.PhoneNumberAreaCodeDigit3;\n        } else {\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    function statePhoneNumberAreaCodeDigit3(stateMachine: StateMachine, char: string) {\n        if (char === ')') {\n            stateMachine.state = State.PhoneNumberCloseParen;\n        } else {\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    function statePhoneNumberCloseParen(stateMachine: StateMachine, char: string) {\n        if (digitRe.test(char)) {\n            stateMachine.state = State.PhoneNumberDigit;\n        } else if (isPhoneNumberSeparatorChar(char)) {\n            stateMachine.state = State.PhoneNumberSeparator;\n        } else {\n            remove(stateMachines, stateMachine);\n        }\n    }\n\n    function statePhoneNumberDigit(stateMachine: StateMachine, char: string) {\n        // For now, if we've reached any digits, we'll say that the machine\n        // has reached its accept state. The phone regex will confirm the\n        // match later.\n        // Alternatively, we could count the number of digits to avoid\n        // invoking the phone number regex\n        stateMachine.acceptStateReached = true;\n\n        if (isPhoneNumberControlChar(char)) {\n            stateMachine.state = State.PhoneNumberControlChar;\n        } else if (char === '#') {\n            stateMachine.state = State.PhoneNumberPoundChar;\n        } else if (digitRe.test(char)) {\n            // Stay in the phone number digit state\n        } else if (char === '(') {\n            stateMachine.state = State.PhoneNumberOpenParen;\n        } else if (isPhoneNumberSeparatorChar(char)) {\n            stateMachine.state = State.PhoneNumberSeparator;\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n\n            // The transition from a digit character to a letter can be the\n            // start of a new scheme URL match\n            if (isSchemeStartChar(char)) {\n                stateMachines.push(createSchemeUrlStateMachine(charIdx, State.SchemeChar));\n            }\n        }\n    }\n\n    function statePhoneNumberSeparator(stateMachine: StateMachine, char: string) {\n        if (digitRe.test(char)) {\n            stateMachine.state = State.PhoneNumberDigit;\n        } else if (char === '(') {\n            stateMachine.state = State.PhoneNumberOpenParen;\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n\n            // This character may start a new match. Add states for it\n            stateNoMatch(char);\n        }\n    }\n\n    // The \";\" characters is \"wait\" in a phone number\n    // The \",\" characters is \"pause\" in a phone number\n    function statePhoneNumberControlChar(stateMachine: StateMachine, char: string) {\n        if (isPhoneNumberControlChar(char)) {\n            // Stay in the \"control char\" state\n        } else if (char === '#') {\n            stateMachine.state = State.PhoneNumberPoundChar;\n        } else if (digitRe.test(char)) {\n            stateMachine.state = State.PhoneNumberDigit;\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    // The \"#\" characters is \"pound\" in a phone number\n    function statePhoneNumberPoundChar(stateMachine: StateMachine, char: string) {\n        if (isPhoneNumberControlChar(char)) {\n            stateMachine.state = State.PhoneNumberControlChar;\n        } else if (digitRe.test(char)) {\n            // According to some of the older tests, if there's a digit\n            // after a '#' sign, the match is invalid. TODO: Revisit if this is true\n            remove(stateMachines, stateMachine);\n        } else {\n            captureMatchIfValidAndRemove(stateMachine);\n        }\n    }\n\n    /*\n     * Captures a match if it is valid (i.e. has a full domain name for a\n     * TLD match). If a match is not valid, it is possible that we want to\n     * keep reading characters in order to make a full match.\n     */\n    function captureMatchIfValidAndRemove(stateMachine: StateMachine) {\n        // Remove the state machine first. There are a number of code paths\n        // which return out of this function early, so make sure we have\n        // this done\n        remove(stateMachines, stateMachine);\n\n        // Make sure the state machine being checked has actually reached an\n        // \"accept\" state. If it hasn't reach one, it can't be a match\n        if (!stateMachine.acceptStateReached) {\n            return;\n        }\n\n        let startIdx = stateMachine.startIdx;\n        let matchedText = text.slice(stateMachine.startIdx, charIdx);\n\n        // Handle any unbalanced braces (parens, square brackets, or curly\n        // brackets) inside the URL. This handles situations like:\n        //     The link (google.com)\n        // and\n        //     Check out this link here (en.wikipedia.org/wiki/IANA_(disambiguation))\n        //\n        // And also remove any punctuation chars at the end such as:\n        //     '?', ',', ':', '.', etc.\n        matchedText = excludeUnbalancedTrailingBracesAndPunctuation(matchedText);\n\n        if (stateMachine.type === 'url') {\n            // We don't want to accidentally match a URL that is preceded by an\n            // '@' character, which would be an email address\n            const charBeforeUrlMatch = text.charAt(stateMachine.startIdx - 1);\n            if (charBeforeUrlMatch === '@') {\n                return;\n            }\n\n            // For the purpose of this parser, we've generalized 'www'\n            // matches as part of 'tld' matches. However, for backward\n            // compatibility, we distinguish beween TLD matches and matches\n            // that begin with 'www.' so that users may turn off 'www'\n            // matches. As such, we need to correct for that now if the\n            // URL begins with 'www.'\n            const urlMatchType: UrlMatchType = stateMachine.matchType;\n\n            if (urlMatchType === 'scheme') {\n                // Autolinker accepts many characters in a url's scheme (like `fake://test.com`).\n                // However, in cases where a URL is missing whitespace before an obvious link,\n                // (for example: `nowhitespacehttp://www.test.com`), we only want the match to start\n                // at the http:// part. We will check if the match contains a common scheme and then\n                // shift the match to start from there.\n                const httpSchemeMatch = httpSchemeRe.exec(matchedText);\n                if (httpSchemeMatch) {\n                    // If we found an overmatched URL, we want to find the index\n                    // of where the match should start and shift the match to\n                    // start from the beginning of the common scheme\n                    startIdx = startIdx + httpSchemeMatch.index;\n                    matchedText = matchedText.slice(httpSchemeMatch.index);\n                }\n\n                if (!isValidSchemeUrl(matchedText)) {\n                    return; // not a valid match\n                }\n            } else if (urlMatchType === 'tld') {\n                if (!isValidTldMatch(matchedText)) {\n                    return; // not a valid match\n                }\n            } else if (urlMatchType === 'ipV4') {\n                if (!isValidIpV4Address(matchedText)) {\n                    return; // not a valid match\n                }\n            } else {\n                assertNever(urlMatchType);\n            }\n\n            matches.push(\n                new UrlMatch({\n                    tagBuilder: tagBuilder,\n                    matchedText: matchedText,\n                    offset: startIdx,\n                    urlMatchType: urlMatchType,\n                    url: matchedText,\n                    protocolRelativeMatch: matchedText.slice(0, 2) === '//',\n\n                    // TODO: Do these settings need to be passed to the match,\n                    // or should we handle them here in UrlMatcher?\n                    stripPrefix: stripPrefix,\n                    stripTrailingSlash: stripTrailingSlash,\n                    decodePercentEncoding: decodePercentEncoding,\n                })\n            );\n        } else if (stateMachine.type === 'email') {\n            // if the email address has a valid TLD, add it to the list of matches\n            if (isValidEmail(matchedText)) {\n                matches.push(\n                    new EmailMatch({\n                        tagBuilder: tagBuilder,\n                        matchedText: matchedText,\n                        offset: startIdx,\n                        email: matchedText.replace(mailtoSchemePrefixRe, ''),\n                    })\n                );\n            }\n        } else if (stateMachine.type === 'hashtag') {\n            if (isValidHashtag(matchedText)) {\n                matches.push(\n                    new HashtagMatch({\n                        tagBuilder,\n                        matchedText: matchedText,\n                        offset: startIdx,\n                        serviceName: hashtagServiceName,\n                        hashtag: matchedText.slice(1),\n                    })\n                );\n            }\n        } else if (stateMachine.type === 'mention') {\n            if (isValidMention(matchedText, mentionServiceName)) {\n                matches.push(\n                    new MentionMatch({\n                        tagBuilder: tagBuilder,\n                        matchedText: matchedText,\n                        offset: startIdx,\n                        serviceName: mentionServiceName,\n                        mention: matchedText.slice(1), // strip off the '@' character at the beginning\n                    })\n                );\n            }\n        } else if (stateMachine.type === 'phone') {\n            // remove any trailing spaces that were considered as \"separator\"\n            // chars by the state machine\n            matchedText = matchedText.replace(/ +$/g, '');\n\n            if (isValidPhoneNumber(matchedText)) {\n                const cleanNumber = matchedText.replace(/[^0-9,;#]/g, ''); // strip out non-digit characters exclude comma semicolon and #\n\n                matches.push(\n                    new PhoneMatch({\n                        tagBuilder: tagBuilder,\n                        matchedText: matchedText,\n                        offset: startIdx,\n                        number: cleanNumber,\n                        plusSign: matchedText.charAt(0) === '+',\n                    })\n                );\n            }\n        } else {\n            assertNever(stateMachine);\n        }\n    }\n}\n\nexport interface ParseMatchesArgs {\n    tagBuilder: AnchorTagBuilder;\n    stripPrefix: Required<StripPrefixConfigObj>;\n    stripTrailingSlash: boolean;\n    decodePercentEncoding: boolean;\n    hashtagServiceName: HashtagService;\n    mentionServiceName: MentionService;\n}\n\nconst openBraceRe = /[\\(\\{\\[]/;\nconst closeBraceRe = /[\\)\\}\\]]/;\nconst oppositeBrace: { [char: string]: string } = {\n    ')': '(',\n    '}': '{',\n    ']': '[',\n};\n\n/**\n * Determines if a match found has unmatched closing parenthesis,\n * square brackets or curly brackets. If so, these unbalanced symbol(s) will be\n * removed from the URL match itself.\n *\n * A match may have an extra closing parenthesis/square brackets/curly brackets\n * at the end of the match because these are valid URL path characters. For\n * example, \"wikipedia.com/something_(disambiguation)\" should be auto-linked.\n *\n * However, an extra parenthesis *will* be included when the URL itself is\n * wrapped in parenthesis, such as in the case of:\n *\n *     \"(wikipedia.com/something_(disambiguation))\"\n *\n * In this case, the last closing parenthesis should *not* be part of the\n * URL itself, and this method will exclude it from the returned URL.\n *\n * For square brackets in URLs such as in PHP arrays, the same behavior as\n * parenthesis discussed above should happen:\n *\n *     \"[http://www.example.com/foo.php?bar[]=1&bar[]=2&bar[]=3]\"\n *\n * The very last closing square bracket should not be part of the URL itself,\n * and therefore this method will remove it.\n *\n * @param matchedText The full matched URL/email/hashtag/etc. from the state\n *   machine parser.\n * @return The updated matched text with extraneous suffix characters removed.\n */\nexport function excludeUnbalancedTrailingBracesAndPunctuation(matchedText: string): string {\n    const braceCounts: { [char: string]: number } = {\n        '(': 0,\n        '{': 0,\n        '[': 0,\n    };\n\n    for (let i = 0; i < matchedText.length; i++) {\n        const char = matchedText.charAt(i);\n\n        if (openBraceRe.test(char)) {\n            braceCounts[char]++;\n        } else if (closeBraceRe.test(char)) {\n            braceCounts[oppositeBrace[char]]--;\n        }\n    }\n\n    let endIdx = matchedText.length - 1;\n    let char: string;\n    while (endIdx >= 0) {\n        char = matchedText.charAt(endIdx);\n\n        if (closeBraceRe.test(char)) {\n            const oppositeBraceChar = oppositeBrace[char];\n\n            if (braceCounts[oppositeBraceChar] < 0) {\n                braceCounts[oppositeBraceChar]++;\n                endIdx--;\n            } else {\n                break;\n            }\n        } else if (urlSuffixedCharsNotAllowedAtEndRe.test(char)) {\n            // Walk back a punctuation char like '?', ',', ':', '.', etc.\n            endIdx--;\n        } else {\n            break;\n        }\n    }\n\n    return matchedText.slice(0, endIdx + 1);\n}\n\n// States for the parser\n// For debugging: temporarily remove 'const'\nconst enum State {\n    // Scheme states\n    SchemeChar = 0, // First char must be an ASCII letter. Subsequent characters can be: ALPHA / DIGIT / \"+\" / \"-\" / \".\"\n    SchemeHyphen, // Extra state used to figure out when we can start a new match after (such as if we have '-//' which starts a protocol-relative match)\n    SchemeColon, // Once we've reached the colon character after a scheme name\n    SchemeSlash1,\n    SchemeSlash2,\n\n    DomainLabelChar, // Note: Domain labels must begin with a letter or number (no hyphens), and can include unicode letters\n    DomainHyphen,\n    DomainDot,\n    PortColon,\n    PortNumber,\n    Path,\n\n    // Protocol-relative URL states\n    ProtocolRelativeSlash1,\n    ProtocolRelativeSlash2,\n\n    // IPv4 States\n    IpV4Digit,\n    IpV4Dot,\n\n    // Email Address States\n    EmailMailto_M, // if matching a 'mailto:' prefix\n    EmailMailto_A, // if matching a 'mailto:' prefix\n    EmailMailto_I, // if matching a 'mailto:' prefix\n    EmailMailto_L, // if matching a 'mailto:' prefix\n    EmailMailto_T, // if matching a 'mailto:' prefix\n    EmailMailto_O, // if matching a 'mailto:' prefix\n    EmailMailto_Colon,\n    EmailLocalPart,\n    EmailLocalPartDot,\n    EmailAtSign,\n    EmailDomainChar,\n    EmailDomainHyphen,\n    EmailDomainDot,\n\n    // Hashtag States\n    HashtagHashChar, // When we've encountered the '#' char\n    HashtagTextChar, // Inside a hashtag char\n\n    // Mention State\n    MentionAtChar,\n    MentionTextChar,\n\n    // Phone Number States\n    PhoneNumberOpenParen,\n    PhoneNumberAreaCodeDigit1, // a digit inside area code parens, such as the '1' in '(123)456-7890'\n    PhoneNumberAreaCodeDigit2, // a digit inside area code parens, such as the '2' in '(123)456-7890'\n    PhoneNumberAreaCodeDigit3, // a digit inside area code parens, such as the '3' in '(123)456-7890'\n    PhoneNumberCloseParen,\n    PhoneNumberPlus,\n    PhoneNumberDigit, // a digit outside of area code parens\n    PhoneNumberSeparator, // '-', '.' or ' '\n    PhoneNumberControlChar, // ',' for 1 second pause, ';' for \"wait\" for user to take action\n    PhoneNumberPoundChar, // '#' for pound character\n}\n\ntype StateMachine =\n    | UrlStateMachine\n    | EmailStateMachine\n    | MentionStateMachine\n    | HashtagStateMachine\n    | PhoneNumberStateMachine;\n\ninterface AbstractStateMachine {\n    startIdx: number; // the index of the first character in the match\n    state: State;\n    acceptStateReached: boolean;\n}\n\ninterface AbstractUrlStateMachine extends AbstractStateMachine {\n    readonly type: 'url';\n}\n\ntype UrlStateMachine = SchemeUrlStateMachine | TldUrlStateMachine | IpV4UrlStateMachine;\n\n/**\n * State machine with metadata for capturing TLD (top-level domain) URLs.\n */\ninterface SchemeUrlStateMachine extends AbstractUrlStateMachine {\n    readonly matchType: 'scheme';\n}\n\n/**\n * State machine with metadata for capturing TLD (top-level domain) URLs.\n */\ninterface TldUrlStateMachine extends AbstractUrlStateMachine {\n    readonly matchType: 'tld';\n}\n\n/**\n * State machine for capturing IPv4 addresses that are not prefixed with a\n * scheme (such as 'http://').\n */\ninterface IpV4UrlStateMachine extends AbstractUrlStateMachine {\n    readonly matchType: 'ipV4';\n    octetsEncountered: number; // if we encounter a number of octets other than 4, it's not an IPv4 address\n}\n\n/**\n * State machine for capturing email addresses.\n */\ninterface EmailStateMachine extends AbstractStateMachine {\n    readonly type: 'email';\n}\n\n/**\n * State machine for capturing hashtags.\n */\ninterface HashtagStateMachine extends AbstractStateMachine {\n    readonly type: 'hashtag';\n}\n\n/**\n * State machine for capturing hashtags.\n */\ninterface MentionStateMachine extends AbstractStateMachine {\n    readonly type: 'mention';\n}\n\n/**\n * State machine for capturing phone numbers.\n *\n * Note: this doesn't actually capture phone numbers at the moment, but is used\n * to exclude phone number matches from URLs where the URL matcher would\n * otherwise potentially think a phone number is part of a domain label.\n */\ninterface PhoneNumberStateMachine extends AbstractStateMachine {\n    readonly type: 'phone';\n}\n\nfunction createSchemeUrlStateMachine(startIdx: number, state: State): SchemeUrlStateMachine {\n    return {\n        type: 'url',\n        startIdx,\n        state,\n        acceptStateReached: false,\n        matchType: 'scheme',\n    };\n}\n\nfunction createTldUrlStateMachine(startIdx: number, state: State): TldUrlStateMachine {\n    return {\n        type: 'url',\n        startIdx,\n        state,\n        acceptStateReached: false,\n        matchType: 'tld',\n    };\n}\n\nfunction createIpV4UrlStateMachine(startIdx: number, state: State): IpV4UrlStateMachine {\n    return {\n        type: 'url',\n        startIdx,\n        state,\n        acceptStateReached: false,\n        matchType: 'ipV4',\n        octetsEncountered: 1, // starts at 1 because we create this machine when encountering the first octet\n    };\n}\n\nfunction createEmailStateMachine(startIdx: number, state: State): EmailStateMachine {\n    return {\n        type: 'email',\n        startIdx,\n        state,\n        acceptStateReached: false,\n    };\n}\n\nfunction createHashtagStateMachine(startIdx: number, state: State): HashtagStateMachine {\n    return {\n        type: 'hashtag',\n        startIdx,\n        state,\n        acceptStateReached: false,\n    };\n}\n\nfunction createMentionStateMachine(startIdx: number, state: State): MentionStateMachine {\n    return {\n        type: 'mention',\n        startIdx,\n        state,\n        acceptStateReached: false,\n    };\n}\n\nfunction createPhoneNumberStateMachine(startIdx: number, state: State): PhoneNumberStateMachine {\n    return {\n        type: 'phone',\n        startIdx,\n        state,\n        acceptStateReached: false,\n    };\n}\n\nfunction isSchemeUrlStateMachine(machine: StateMachine): machine is SchemeUrlStateMachine {\n    return machine.type === 'url' && machine.matchType === 'scheme';\n}\n"]}