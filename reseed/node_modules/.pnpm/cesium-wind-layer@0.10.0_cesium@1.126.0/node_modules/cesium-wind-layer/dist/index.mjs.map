{"version":3,"sources":["../src/index.ts","../src/windParticlesComputing.ts","../src/shaderManager.ts","../src/shaders/updatePosition.ts","../src/shaders/calculateSpeed.ts","../src/shaders/postProcessingPosition.ts","../src/shaders/segmentDraw.ts","../src/customPrimitive.ts","../src/utils.ts","../src/windParticlesRendering.ts","../src/windParticleSystem.ts"],"sourcesContent":["import {\n  Viewer,\n  Scene,\n  Cartesian2,\n  SceneMode,\n  Math as CesiumMath,\n  Rectangle\n} from 'cesium';\n\nimport { WindLayerOptions, WindData, WindDataAtLonLat } from './types';\nimport { WindParticleSystem } from './windParticleSystem';\nimport { deepMerge } from './utils';\n\nexport * from './types';\n\ntype WindLayerEventType = 'dataChange' | 'optionsChange';\ntype WindLayerEventCallback = (data: WindData | WindLayerOptions) => void;\n\nexport const DefaultOptions: WindLayerOptions = {\n  particlesTextureSize: 100,\n  dropRate: 0.003,\n  particleHeight: 1000,\n  dropRateBump: 0.01,\n  speedFactor: 1.0,\n  lineWidth: { min: 1, max: 2 },\n  lineLength: { min: 20, max: 100 },\n  colors: ['white'],\n  flipY: false,\n  useViewerBounds: false,\n  domain: undefined,\n  displayRange: undefined,\n  dynamic: true\n}\n\nexport class WindLayer {\n  private _show: boolean = true;\n  private _resized: boolean = false;\n  windData: Required<WindData>;\n\n  get show(): boolean {\n    return this._show;\n  }\n\n  set show(value: boolean) {\n    if (this._show !== value) {\n      this._show = value;\n      this.updatePrimitivesVisibility(value);\n    }\n  }\n\n  static defaultOptions: WindLayerOptions = DefaultOptions;\n\n  viewer: Viewer;\n  scene: Scene;\n  options: WindLayerOptions;\n  private particleSystem: WindParticleSystem;\n  private viewerParameters: {\n    lonRange: Cartesian2;\n    latRange: Cartesian2;\n    pixelSize: number;\n    sceneMode: SceneMode;\n  };\n  private _isDestroyed: boolean = false;\n  private primitives: any[] = [];\n  private eventListeners: Map<WindLayerEventType, Set<WindLayerEventCallback>> = new Map();\n\n  /**\n   * WindLayer class for visualizing wind field data with particle animation in Cesium.\n   * \n   * @class\n   * @param {Viewer} viewer - The Cesium viewer instance.\n   * @param {WindData} windData - The wind field data to visualize.\n   * @param {Partial<WindLayerOptions>} [options] - Optional configuration options for the wind layer.\n   * @param {number} [options.particlesTextureSize=100] - Size of the particle texture. Determines the maximum number of particles (size squared).\n   * @param {number} [options.particleHeight=0] - Height of particles above the ground in meters.\n   * @param {Object} [options.lineWidth={ min: 1, max: 2 }] - Width range of particle trails.\n   * @param {Object} [options.lineLength={ min: 20, max: 100 }] - Length range of particle trails.\n   * @param {number} [options.speedFactor=1.0] - Factor to adjust the speed of particles.\n   * @param {number} [options.dropRate=0.003] - Rate at which particles are dropped (reset).\n   * @param {number} [options.dropRateBump=0.001] - Additional drop rate for slow-moving particles.\n   * @param {string[]} [options.colors=['white']] - Array of colors for particles. Can be used to create color gradients.\n   * @param {boolean} [options.flipY=false] - Whether to flip the Y-axis of the wind data.\n   * @param {boolean} [options.useViewerBounds=false] - Whether to use the viewer bounds to generate particles.\n   * @param {boolean} [options.dynamic=true] - Whether to enable dynamic particle animation.\n   */\n  constructor(viewer: Viewer, windData: WindData, options?: Partial<WindLayerOptions>) {\n    this.show = true;\n    this.viewer = viewer;\n    this.scene = viewer.scene;\n    this.options = { ...WindLayer.defaultOptions, ...options };\n    this.windData = this.processWindData(windData);\n\n    this.viewerParameters = {\n      lonRange: new Cartesian2(-180, 180),\n      latRange: new Cartesian2(-90, 90),\n      pixelSize: 1000.0,\n      sceneMode: this.scene.mode\n    };\n    this.updateViewerParameters();\n\n    this.particleSystem = new WindParticleSystem(this.scene.context, this.windData, this.options, this.viewerParameters, this.scene);\n    this.add();\n\n    this.setupEventListeners();\n  }\n\n  private setupEventListeners(): void {\n    this.viewer.camera.percentageChanged = 0.01;\n    this.viewer.camera.changed.addEventListener(this.updateViewerParameters.bind(this));\n    this.scene.morphComplete.addEventListener(this.updateViewerParameters.bind(this));\n    window.addEventListener(\"resize\", this.updateViewerParameters.bind(this));\n  }\n\n  private removeEventListeners(): void {\n    this.viewer.camera.changed.removeEventListener(this.updateViewerParameters.bind(this));\n    this.scene.morphComplete.removeEventListener(this.updateViewerParameters.bind(this));\n    window.removeEventListener(\"resize\", this.updateViewerParameters.bind(this));\n  }\n\n  private processWindData(windData: WindData): Required<WindData> {\n    if (windData.speed?.min === undefined || windData.speed?.max === undefined || windData.speed.array === undefined) {\n      const speed = {\n        array: new Float32Array(windData.u.array.length),\n        min: Number.MAX_VALUE,\n        max: Number.MIN_VALUE\n      };\n      for (let i = 0; i < windData.u.array.length; i++) {\n        speed.array[i] = Math.sqrt(windData.u.array[i] * windData.u.array[i] + windData.v.array[i] * windData.v.array[i]);\n        if (speed.array[i] !== 0) {\n          speed.min = Math.min(speed.min, speed.array[i]);\n          speed.max = Math.max(speed.max, speed.array[i]);\n        }\n      }\n      windData = { ...windData, speed };\n    }\n\n    return windData as Required<WindData>;\n  }\n\n  /**\n   * Get the wind data at a specific longitude and latitude.\n   * @param {number} lon - The longitude.\n   * @param {number} lat - The latitude.\n   * @returns {Object} - An object containing the u, v, and speed values at the specified coordinates.\n   */\n  getDataAtLonLat(lon: number, lat: number): WindDataAtLonLat | null {\n    const { bounds, width, height, u, v, speed } = this.windData;\n    const { flipY } = this.options;\n\n    // Check if the coordinates are within bounds\n    if (lon < bounds.west || lon > bounds.east || lat < bounds.south || lat > bounds.north) {\n      return null;\n    }\n\n    // Calculate normalized coordinates\n    const xNorm = (lon - bounds.west) / (bounds.east - bounds.west) * (width - 1);\n    let yNorm = (lat - bounds.south) / (bounds.north - bounds.south) * (height - 1);\n\n    // Apply flipY if enabled\n    if (flipY) {\n      yNorm = height - 1 - yNorm;\n    }\n\n    // Get exact grid point for original values\n    const x = Math.floor(xNorm);\n    const y = Math.floor(yNorm);\n\n    // Get the four surrounding grid points for interpolation\n    const x0 = Math.floor(xNorm);\n    const x1 = Math.min(x0 + 1, width - 1);\n    const y0 = Math.floor(yNorm);\n    const y1 = Math.min(y0 + 1, height - 1);\n\n    // Calculate interpolation weights\n    const wx = xNorm - x0;\n    const wy = yNorm - y0;\n\n    // Get indices\n    const index = y * width + x;\n    const i00 = y0 * width + x0;\n    const i10 = y0 * width + x1;\n    const i01 = y1 * width + x0;\n    const i11 = y1 * width + x1;\n\n    // Bilinear interpolation for u component\n    const u00 = u.array[i00];\n    const u10 = u.array[i10];\n    const u01 = u.array[i01];\n    const u11 = u.array[i11];\n    const uInterp = (1 - wx) * (1 - wy) * u00 + wx * (1 - wy) * u10 +\n      (1 - wx) * wy * u01 + wx * wy * u11;\n\n    // Bilinear interpolation for v component\n    const v00 = v.array[i00];\n    const v10 = v.array[i10];\n    const v01 = v.array[i01];\n    const v11 = v.array[i11];\n    const vInterp = (1 - wx) * (1 - wy) * v00 + wx * (1 - wy) * v10 +\n      (1 - wx) * wy * v01 + wx * wy * v11;\n\n    // Calculate interpolated speed\n    const interpolatedSpeed = Math.sqrt(uInterp * uInterp + vInterp * vInterp);\n\n    return {\n      original: {\n        u: u.array[index],\n        v: v.array[index],\n        speed: speed.array[index],\n      },\n      interpolated: {\n        u: uInterp,\n        v: vInterp,\n        speed: interpolatedSpeed,\n      }\n    };\n  }\n\n  private updateViewerParameters(): void {\n    const scene = this.viewer.scene;\n    const canvas = scene.canvas;\n    const corners = [\n      { x: 0, y: 0 },\n      { x: 0, y: canvas.clientHeight },\n      { x: canvas.clientWidth, y: 0 },\n      { x: canvas.clientWidth, y: canvas.clientHeight }\n    ];\n\n    // Convert screen corners to cartographic coordinates\n    let minLon = 180;\n    let maxLon = -180;\n    let minLat = 90;\n    let maxLat = -90;\n    let isOutsideGlobe = false;\n\n    for (const corner of corners) {\n      const cartesian = scene.camera.pickEllipsoid(\n        new Cartesian2(corner.x, corner.y),\n        scene.globe.ellipsoid\n      );\n\n      if (!cartesian) {\n        isOutsideGlobe = true;\n        break;\n      }\n\n      const cartographic = scene.globe.ellipsoid.cartesianToCartographic(cartesian);\n      const lon = CesiumMath.toDegrees(cartographic.longitude);\n      const lat = CesiumMath.toDegrees(cartographic.latitude);\n\n      minLon = Math.min(minLon, lon);\n      maxLon = Math.max(maxLon, lon);\n      minLat = Math.min(minLat, lat);\n      maxLat = Math.max(maxLat, lat);\n    }\n\n    if (!isOutsideGlobe) { // -30 degrees in radians\n      // Calculate intersection with data bounds\n      const lonRange = new Cartesian2(\n        Math.max(this.windData.bounds.west, minLon),\n        Math.min(this.windData.bounds.east, maxLon)\n      );\n      const latRange = new Cartesian2(\n        Math.max(this.windData.bounds.south, minLat),\n        Math.min(this.windData.bounds.north, maxLat)\n      );\n\n      // Add 5% buffer to lonRange and latRange\n      const lonBuffer = (lonRange.y - lonRange.x) * 0.05;\n      const latBuffer = (latRange.y - latRange.x) * 0.05;\n\n      lonRange.x = Math.max(this.windData.bounds.west, lonRange.x - lonBuffer);\n      lonRange.y = Math.min(this.windData.bounds.east, lonRange.y + lonBuffer);\n      latRange.x = Math.max(this.windData.bounds.south, latRange.x - latBuffer);\n      latRange.y = Math.min(this.windData.bounds.north, latRange.y + latBuffer);\n\n      this.viewerParameters.lonRange = lonRange;\n      this.viewerParameters.latRange = latRange;\n      // Calculate pixelSize based on the visible range\n      const dataLonRange = this.windData.bounds.east - this.windData.bounds.west;\n      const dataLatRange = this.windData.bounds.north - this.windData.bounds.south;\n\n      // Calculate the ratio of visible area to total data area based on the shortest side\n      const visibleRatioLon = (lonRange.y - lonRange.x) / dataLonRange;\n      const visibleRatioLat = (latRange.y - latRange.x) / dataLatRange;\n      const visibleRatio = Math.min(visibleRatioLon, visibleRatioLat);\n\n      // Map the ratio to a pixelSize value between 0 and 1000\n      const pixelSize = 1000 * visibleRatio;\n      if (pixelSize > 0) {\n        this.viewerParameters.pixelSize = Math.max(0, Math.min(1000, pixelSize));\n      }\n    }\n\n\n    this.viewerParameters.sceneMode = this.scene.mode;\n    this.particleSystem?.applyViewerParameters(this.viewerParameters);\n  }\n\n  /**\n   * Update the wind data of the wind layer.\n   * @param {WindData} data - The new wind data to apply.\n   */\n  updateWindData(data: WindData): void {\n    if (this._isDestroyed) return;\n    this.windData = this.processWindData(data);\n    this.particleSystem.computing.updateWindData(this.windData);\n    this.viewer.scene.requestRender();\n    // Dispatch data change event\n    this.dispatchEvent('dataChange', this.windData);\n  }\n\n  /**\n   * Update the options of the wind layer.\n   * @param {Partial<WindLayerOptions>} options - The new options to apply.\n   */\n  updateOptions(options: Partial<WindLayerOptions>): void {\n    if (this._isDestroyed) return;\n    this.options = deepMerge(options, this.options);\n    this.particleSystem.changeOptions(options);\n    this.viewer.scene.requestRender();\n    // Dispatch options change event\n    this.dispatchEvent('optionsChange', this.options);\n  }\n\n  /**\n   * Zoom to the wind data bounds.\n   * @param {number} [duration=0] - The duration of the zoom animation.\n   */\n  zoomTo(duration: number = 0): void {\n    if (this.windData.bounds) {\n      const rectangle = Rectangle.fromDegrees(\n        this.windData.bounds.west,\n        this.windData.bounds.south,\n        this.windData.bounds.east,\n        this.windData.bounds.north\n      );\n      this.viewer.camera.flyTo({\n        destination: rectangle,\n        duration,\n      });\n    }\n  }\n\n  /**\n   * Add the wind layer to the scene.\n   */\n  add(): void {\n    this.primitives = this.particleSystem.getPrimitives();\n    this.primitives.forEach(primitive => {\n      this.scene.primitives.add(primitive);\n    });\n  }\n\n  /**\n   * Remove the wind layer from the scene.\n   */\n  remove(): void {\n    this.primitives.forEach(primitive => {\n      this.scene.primitives.remove(primitive);\n    });\n    this.primitives = [];\n  }\n\n  /**\n   * Check if the wind layer is destroyed.\n   * @returns {boolean} - True if the wind layer is destroyed, otherwise false.\n   */\n  isDestroyed(): boolean {\n    return this._isDestroyed;\n  }\n\n  /**\n   * Destroy the wind layer and release all resources.\n   */\n  destroy(): void {\n    this.remove();\n    this.removeEventListeners();\n    this.particleSystem.destroy();\n    // Clear all event listeners\n    this.eventListeners.clear();\n    this._isDestroyed = true;\n  }\n\n  private updatePrimitivesVisibility(visibility?: boolean): void {\n    const show = visibility !== undefined ? visibility : this._show;\n    this.primitives.forEach(primitive => {\n      primitive.show = show;\n    });\n  }\n\n  /**\n   * Add an event listener for the specified event type.\n   * @param {WindLayerEventType} type - The type of event to listen for.\n   * @param {WindLayerEventCallback} callback - The callback function to execute when the event occurs.\n   */\n  addEventListener(type: WindLayerEventType, callback: WindLayerEventCallback) {\n    if (!this.eventListeners.has(type)) {\n      this.eventListeners.set(type, new Set());\n    }\n    this.eventListeners.get(type)?.add(callback);\n  }\n\n  /**\n   * Remove an event listener for the specified event type.\n   * @param {WindLayerEventType} type - The type of event to remove.\n   * @param {WindLayerEventCallback} callback - The callback function to remove.\n   */\n  removeEventListener(type: WindLayerEventType, callback: WindLayerEventCallback) {\n    this.eventListeners.get(type)?.delete(callback);\n  }\n\n  private dispatchEvent(type: WindLayerEventType, data: WindData | WindLayerOptions) {\n    this.eventListeners.get(type)?.forEach(callback => callback(data));\n  }\n\n}\n\nexport type { WindLayerOptions, WindData, WindLayerEventType, WindLayerEventCallback };\n","import { PixelDatatype, PixelFormat, Sampler, Texture, TextureMagnificationFilter, TextureMinificationFilter, Cartesian2, FrameRateMonitor } from 'cesium';\nimport { WindLayerOptions, WindData } from './types';\nimport { ShaderManager } from './shaderManager';\nimport CustomPrimitive from './customPrimitive'\nimport { deepMerge } from './utils';\n\nexport class WindParticlesComputing {\n  context: any;\n  options: WindLayerOptions;\n  viewerParameters: any;\n  windTextures!: {\n    U: Texture;\n    V: Texture;\n  };\n  particlesTextures!: {\n    previousParticlesPosition: Texture;\n    currentParticlesPosition: Texture;\n    nextParticlesPosition: Texture;\n    postProcessingPosition: Texture;\n    particlesSpeed: Texture;\n  };\n  primitives!: {\n    calculateSpeed: CustomPrimitive;\n    updatePosition: CustomPrimitive;\n    postProcessingPosition: CustomPrimitive;\n  };\n  windData: Required<WindData>;\n  private frameRateMonitor: FrameRateMonitor;\n  frameRate: number = 60;\n  frameRateAdjustment: number = 1;\n\n  constructor(context: any, windData: Required<WindData>, options: WindLayerOptions, viewerParameters: any, scene: any) {\n    this.context = context;\n    this.options = options;\n    this.viewerParameters = viewerParameters;\n    this.windData = windData;\n\n    this.frameRateMonitor = new FrameRateMonitor({\n      scene: scene,\n      samplingWindow: 1.0,\n      quietPeriod: 0.0\n    });\n    this.initFrameRate();\n    this.createWindTextures();\n    this.createParticlesTextures();\n    this.createComputingPrimitives();\n  }\n\n  private initFrameRate() {\n    const updateFrameRate = () => {\n      // avoid update frame rate when frame rate is too low\n      if (this.frameRateMonitor.lastFramesPerSecond > 20) {\n        this.frameRate = this.frameRateMonitor.lastFramesPerSecond;\n        this.frameRateAdjustment = 60 / Math.max(this.frameRate, 1);\n      }\n    }\n\n    // Initial frame rate calculation\n    updateFrameRate();\n\n    // Use setInterval instead of requestAnimationFrame\n    const intervalId = setInterval(updateFrameRate, 1000);\n\n    // Monitor frame rate changes\n    this.frameRateMonitor.lowFrameRate.addEventListener((scene, frameRate) => {\n      console.warn(`Low frame rate detected: ${frameRate} FPS`);\n    });\n\n    this.frameRateMonitor.nominalFrameRate.addEventListener((scene, frameRate) => {\n      console.log(`Frame rate returned to normal: ${frameRate} FPS`);\n    });\n\n    // Add cleanup method to destroy\n    const originalDestroy = this.destroy.bind(this);\n    this.destroy = () => {\n      clearInterval(intervalId);\n      originalDestroy();\n    };\n  }\n\n  createWindTextures() {\n    const options = {\n      context: this.context,\n      width: this.windData.width,\n      height: this.windData.height,\n      pixelFormat: PixelFormat.RED,\n      pixelDatatype: PixelDatatype.FLOAT,\n      flipY: this.options.flipY ?? false,\n      sampler: new Sampler({\n        minificationFilter: TextureMinificationFilter.LINEAR,\n        magnificationFilter: TextureMagnificationFilter.LINEAR\n      })\n    }\n\n    this.windTextures = {\n      U: new Texture({\n        ...options,\n        source: {\n          arrayBufferView: new Float32Array(this.windData.u.array)\n        }\n      }),\n      V: new Texture({\n        ...options,\n        source: {\n          arrayBufferView: new Float32Array(this.windData.v.array)\n        }\n      }),\n    };\n  }\n\n  createParticlesTextures() {\n    const options = {\n      context: this.context,\n      width: this.options.particlesTextureSize,\n      height: this.options.particlesTextureSize,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.FLOAT,\n      flipY: false,\n      source: {\n        arrayBufferView: new Float32Array(this.options.particlesTextureSize * this.options.particlesTextureSize * 4).fill(0)\n      },\n      sampler: new Sampler({\n        minificationFilter: TextureMinificationFilter.NEAREST,\n        magnificationFilter: TextureMagnificationFilter.NEAREST\n      })\n    }\n\n    this.particlesTextures = {\n      previousParticlesPosition: new Texture(options),\n      currentParticlesPosition: new Texture(options),\n      nextParticlesPosition: new Texture(options),\n      postProcessingPosition: new Texture(options),\n      particlesSpeed: new Texture(options)\n    };\n  }\n\n  destroyParticlesTextures() {\n    Object.values(this.particlesTextures).forEach(texture => texture.destroy());\n  }\n\n  createComputingPrimitives() {\n    this.primitives = {\n      calculateSpeed: new CustomPrimitive({\n        commandType: 'Compute',\n        uniformMap: {\n          U: () => this.windTextures.U,\n          V: () => this.windTextures.V,\n          uRange: () => new Cartesian2(this.windData.u.min, this.windData.u.max),\n          vRange: () => new Cartesian2(this.windData.v.min, this.windData.v.max),\n          speedRange: () => new Cartesian2(this.windData.speed.min, this.windData.speed.max),\n          currentParticlesPosition: () => this.particlesTextures.currentParticlesPosition,\n          speedScaleFactor: () => {\n            return (this.viewerParameters.pixelSize + 50) * this.options.speedFactor;\n          },\n          frameRateAdjustment: () => this.frameRateAdjustment,\n          dimension: () => new Cartesian2(this.windData.width, this.windData.height),\n          minimum: () => new Cartesian2(this.windData.bounds.west, this.windData.bounds.south),\n          maximum: () => new Cartesian2(this.windData.bounds.east, this.windData.bounds.north),\n        },\n        fragmentShaderSource: ShaderManager.getCalculateSpeedShader(),\n        outputTexture: this.particlesTextures.particlesSpeed,\n        preExecute: () => {\n          const temp = this.particlesTextures.previousParticlesPosition;\n          this.particlesTextures.previousParticlesPosition = this.particlesTextures.currentParticlesPosition;\n          this.particlesTextures.currentParticlesPosition = this.particlesTextures.postProcessingPosition;\n          this.particlesTextures.postProcessingPosition = temp;\n          if (this.primitives.calculateSpeed.commandToExecute) {\n            this.primitives.calculateSpeed.commandToExecute.outputTexture = this.particlesTextures.particlesSpeed;\n          }\n        },\n        isDynamic: () =>this.options.dynamic\n      }),\n\n      updatePosition: new CustomPrimitive({\n        commandType: 'Compute',\n        uniformMap: {\n          currentParticlesPosition: () => this.particlesTextures.currentParticlesPosition,\n          particlesSpeed: () => this.particlesTextures.particlesSpeed,\n        },\n        fragmentShaderSource: ShaderManager.getUpdatePositionShader(),\n        outputTexture: this.particlesTextures.nextParticlesPosition,\n        preExecute: () => {\n          if (this.primitives.updatePosition.commandToExecute) {\n            this.primitives.updatePosition.commandToExecute.outputTexture = this.particlesTextures.nextParticlesPosition;\n          }\n        },\n        isDynamic: () => this.options.dynamic\n      }),\n\n      postProcessingPosition: new CustomPrimitive({\n        commandType: 'Compute',\n        uniformMap: {\n          nextParticlesPosition: () => this.particlesTextures.nextParticlesPosition,\n          particlesSpeed: () => this.particlesTextures.particlesSpeed,\n          lonRange: () => this.viewerParameters.lonRange,\n          latRange: () => this.viewerParameters.latRange,\n          dataLonRange: () => new Cartesian2(this.windData.bounds.west, this.windData.bounds.east),\n          dataLatRange: () => new Cartesian2(this.windData.bounds.south, this.windData.bounds.north),\n          randomCoefficient: function () {\n            return Math.random();\n          },\n          dropRate: () => this.options.dropRate,\n          dropRateBump: () => this.options.dropRateBump,\n          useViewerBounds: () => this.options.useViewerBounds\n        },\n        fragmentShaderSource: ShaderManager.getPostProcessingPositionShader(),\n        outputTexture: this.particlesTextures.postProcessingPosition,\n        preExecute: () => {\n          if (this.primitives.postProcessingPosition.commandToExecute) {\n            this.primitives.postProcessingPosition.commandToExecute.outputTexture = this.particlesTextures.postProcessingPosition;\n          }\n        },\n        isDynamic: () => this.options.dynamic\n      })\n    };\n  }\n\n  private reCreateWindTextures() {\n    this.windTextures.U.destroy();\n    this.windTextures.V.destroy();\n    this.createWindTextures();\n  }\n\n  updateWindData(data: Required<WindData>) {\n    this.windData = data;\n    this.reCreateWindTextures();\n  }\n\n  updateOptions(options: Partial<WindLayerOptions>) {\n    const needUpdateWindTextures = options.flipY !== undefined && options.flipY !== this.options.flipY;\n    this.options = deepMerge(options, this.options);\n    if (needUpdateWindTextures) {\n      this.reCreateWindTextures();\n    }\n  }\n\n  processWindData(data: {\n    array: Float32Array;\n    min?: number;\n    max?: number;\n  }): Float32Array {\n    const { array } = data;\n    let { min, max } = data;\n    const result = new Float32Array(array.length);\n    if (min === undefined) {\n      console.warn('min is undefined, calculate min');\n      min = Math.min(...array);\n    }\n    if (max === undefined) {\n      console.warn('max is undefined, calculate max');\n      max = Math.max(...array);\n    }\n\n    const maxNum = Math.max(Math.abs(min), Math.abs(max));\n\n    for (let i = 0; i < array.length; i++) {\n      const value = array[i] / maxNum; // Normalize to [-1, 1]\n      result[i] = value;\n    }\n    console.log(result)\n    return result;\n  }\n\n  destroy() {\n    Object.values(this.windTextures).forEach(texture => texture.destroy());\n    Object.values(this.particlesTextures).forEach(texture => texture.destroy());\n    Object.values(this.primitives).forEach(primitive => primitive.destroy());\n    this.frameRateMonitor.destroy();\n  }\n}\n","import { ShaderSource } from 'cesium';\nimport { updatePositionShader } from './shaders/updatePosition';\nimport { calculateSpeedShader } from './shaders/calculateSpeed';\nimport { postProcessingPositionFragmentShader } from './shaders/postProcessingPosition';\nimport { renderParticlesFragmentShader, renderParticlesVertexShader } from './shaders/segmentDraw';\n\nexport class ShaderManager {\n  static getCalculateSpeedShader(): ShaderSource {\n    return new ShaderSource({\n      sources: [calculateSpeedShader]\n    });\n  }\n\n  static getUpdatePositionShader(): ShaderSource {\n    return new ShaderSource({\n      sources: [updatePositionShader]\n    });\n  }\n\n  static getSegmentDrawVertexShader(): ShaderSource {\n    return new ShaderSource({\n      sources: [renderParticlesVertexShader]\n    });\n  }\n\n  static getSegmentDrawFragmentShader(): ShaderSource {\n    return new ShaderSource({\n      sources: [renderParticlesFragmentShader]\n    });\n  }\n\n  static getPostProcessingPositionShader(): ShaderSource {\n    return new ShaderSource({\n      sources: [postProcessingPositionFragmentShader]\n    });\n  }\n\n}\n","export const updatePositionShader = /*glsl*/`#version 300 es\nprecision highp float;\n\nuniform sampler2D currentParticlesPosition;\nuniform sampler2D particlesSpeed;\n\nin vec2 v_textureCoordinates;\n\nout vec4 fragColor;\n\nvoid main() {\n    // 获取当前粒子的位置\n    vec2 currentPos = texture(currentParticlesPosition, v_textureCoordinates).rg;\n    // 获取粒子的速度\n    vec2 speed = texture(particlesSpeed, v_textureCoordinates).rg;\n    // 计算下一个位置\n    vec2 nextPos = currentPos + speed;\n    \n    // 将新的位置写入 fragColor\n    fragColor = vec4(nextPos, 0.0, 1.0);\n}\n`;","export const calculateSpeedShader = /*glsl*/`#version 300 es\n\n// the size of UV textures: width = lon, height = lat\nuniform sampler2D U; // eastward wind\nuniform sampler2D V; // northward wind\nuniform sampler2D currentParticlesPosition; // (lon, lat, lev)\n\nuniform vec2 uRange; // (min, max)\nuniform vec2 vRange; // (min, max)\nuniform vec2 speedRange; // (min, max)\nuniform vec2 dimension; // (lon, lat)\nuniform vec2 minimum; // minimum of each dimension\nuniform vec2 maximum; // maximum of each dimension\n\nuniform float speedScaleFactor;\nuniform float frameRateAdjustment;\n\nin vec2 v_textureCoordinates;\n\nvec2 getInterval(vec2 maximum, vec2 minimum, vec2 dimension) {\n    return (maximum - minimum) / (dimension - 1.0);\n}\n\nvec2 mapPositionToNormalizedIndex2D(vec2 lonLat) {\n    // ensure the range of longitude and latitude\n    lonLat.x = clamp(lonLat.x, minimum.x, maximum.x);\n    lonLat.y = clamp(lonLat.y,  minimum.y, maximum.y);\n\n    vec2 interval = getInterval(maximum, minimum, dimension);\n    \n    vec2 index2D = vec2(0.0);\n    index2D.x = (lonLat.x - minimum.x) / interval.x;\n    index2D.y = (lonLat.y - minimum.y) / interval.y;\n\n    vec2 normalizedIndex2D = vec2(index2D.x / dimension.x, index2D.y / dimension.y);\n    return normalizedIndex2D;\n}\n\nfloat getWindComponent(sampler2D componentTexture, vec2 lonLat) {\n    vec2 normalizedIndex2D = mapPositionToNormalizedIndex2D(lonLat);\n    float result = texture(componentTexture, normalizedIndex2D).r;\n    return result;\n}\n\nvec2 getWindComponents(vec2 lonLat) {\n    vec2 normalizedIndex2D = mapPositionToNormalizedIndex2D(lonLat);\n    float u = texture(U, normalizedIndex2D).r;\n    float v = texture(V, normalizedIndex2D).r;\n    return vec2(u, v);\n}\n\nvec2 bilinearInterpolation(vec2 lonLat) {\n    float lon = lonLat.x;\n    float lat = lonLat.y;\n\n    vec2 interval = getInterval(maximum, minimum, dimension);\n\n    // Calculate grid cell coordinates\n    float lon0 = floor(lon / interval.x) * interval.x;\n    float lon1 = lon0 + interval.x;\n    float lat0 = floor(lat / interval.y) * interval.y;\n    float lat1 = lat0 + interval.y;\n\n    // Get wind vectors at four corners\n    vec2 v00 = getWindComponents(vec2(lon0, lat0));\n    vec2 v10 = getWindComponents(vec2(lon1, lat0));\n    vec2 v01 = getWindComponents(vec2(lon0, lat1));\n    vec2 v11 = getWindComponents(vec2(lon1, lat1));\n\n    // Check if all wind vectors are zero\n    if (length(v00) == 0.0 && length(v10) == 0.0 && length(v01) == 0.0 && length(v11) == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // Calculate interpolation weights\n    float s = (lon - lon0) / interval.x;\n    float t = (lat - lat0) / interval.y;\n\n    // Perform bilinear interpolation on vector components\n    vec2 v0 = mix(v00, v10, s);\n    vec2 v1 = mix(v01, v11, s);\n    return mix(v0, v1, t);\n}\n\nvec2 lengthOfLonLat(vec2 lonLat) {\n    // unit conversion: meters -> longitude latitude degrees\n    // see https://en.wikipedia.org/wiki/Geographic_coordinate_system#Length_of_a_degree for detail\n\n    // Calculate the length of a degree of latitude and longitude in meters\n    float latitude = radians(lonLat.y);\n\n    float term1 = 111132.92;\n    float term2 = 559.82 * cos(2.0 * latitude);\n    float term3 = 1.175 * cos(4.0 * latitude);\n    float term4 = 0.0023 * cos(6.0 * latitude);\n    float latLength = term1 - term2 + term3 - term4;\n\n    float term5 = 111412.84 * cos(latitude);\n    float term6 = 93.5 * cos(3.0 * latitude);\n    float term7 = 0.118 * cos(5.0 * latitude);\n    float longLength = term5 - term6 + term7;\n\n    return vec2(longLength, latLength);\n}\n\nvec2 convertSpeedUnitToLonLat(vec2 lonLat, vec2 speed) {\n    vec2 lonLatLength = lengthOfLonLat(lonLat);\n    float u = speed.x / lonLatLength.x;\n    float v = speed.y / lonLatLength.y;\n    vec2 windVectorInLonLat = vec2(u, v);\n\n    return windVectorInLonLat;\n}\n\nvec2 calculateSpeedByRungeKutta2(vec2 lonLat) {\n    // see https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods#Second-order_methods_with_two_stages for detail\n    const float h = 0.5;\n\n    vec2 y_n = lonLat;\n    vec2 f_n = bilinearInterpolation(lonLat);\n    vec2 midpoint = y_n + 0.5 * h * convertSpeedUnitToLonLat(y_n, f_n) * speedScaleFactor;\n    vec2 speed = h * bilinearInterpolation(midpoint) * speedScaleFactor;\n\n    return speed;\n}\n\n\nvec2 calculateWindNorm(vec2 speed) {\n    float speedLength = length(speed.xy);\n    if(speedLength == 0.0){\n      return vec2(0.0);\n    }\n\n    // Clamp speedLength to range\n    float clampedSpeed = clamp(speedLength, speedRange.x, speedRange.y);\n    float normalizedSpeed = (clampedSpeed - speedRange.x) / (speedRange.y - speedRange.x);\n    return vec2(speedLength, normalizedSpeed);\n}\n\nout vec4 fragColor;\n\nvoid main() {\n    // texture coordinate must be normalized\n    vec2 lonLat = texture(currentParticlesPosition, v_textureCoordinates).rg;\n    vec2 speedOrigin = bilinearInterpolation(lonLat);\n    vec2 speed = calculateSpeedByRungeKutta2(lonLat) * frameRateAdjustment;\n    vec2 speedInLonLat = convertSpeedUnitToLonLat(lonLat, speed);\n\n    fragColor = vec4(speedInLonLat, calculateWindNorm(speedOrigin));\n}\n`;\n","export const postProcessingPositionFragmentShader = /*glsl*/`#version 300 es\nprecision highp float;\n\nuniform sampler2D nextParticlesPosition;\nuniform sampler2D particlesSpeed; // (u, v, norm)\n\n// range (min, max)\nuniform vec2 lonRange;\nuniform vec2 latRange;\n\n// range (min, max)\nuniform vec2 dataLonRange;\nuniform vec2 dataLatRange;\n\nuniform float randomCoefficient;\nuniform float dropRate;\nuniform float dropRateBump;\n\n// 添加新的 uniform 变量\nuniform bool useViewerBounds;\n\nin vec2 v_textureCoordinates;\n\n// pseudo-random generator\nconst vec3 randomConstants = vec3(12.9898, 78.233, 4375.85453);\nconst vec2 normalRange = vec2(0.0, 1.0);\nfloat rand(vec2 seed, vec2 range) {\n    vec2 randomSeed = randomCoefficient * seed;\n    float temp = dot(randomConstants.xy, randomSeed);\n    temp = fract(sin(temp) * (randomConstants.z + temp));\n    return temp * (range.y - range.x) + range.x;\n}\n\nvec2 generateRandomParticle(vec2 seed) {\n    vec2 range;\n    float randomLon, randomLat;\n    \n    if (useViewerBounds) {\n        // 在当前视域范围内生成粒子\n        randomLon = rand(seed, lonRange);\n        randomLat = rand(-seed, latRange);\n    } else {\n        // 在数据范围内生成粒子\n        randomLon = rand(seed, dataLonRange);\n        randomLat = rand(-seed, dataLatRange);\n    }\n\n    return vec2(randomLon, randomLat);\n}\n\nbool particleOutbound(vec2 particle) {\n    return particle.y < dataLatRange.x || particle.y > dataLatRange.y || particle.x < dataLonRange.x || particle.x > dataLonRange.y;\n}\n\nout vec4 fragColor;\n\nvoid main() {\n    vec2 nextParticle = texture(nextParticlesPosition, v_textureCoordinates).rg;\n    vec4 nextSpeed = texture(particlesSpeed, v_textureCoordinates);\n    float speedNorm = nextSpeed.a;\n    float particleDropRate = dropRate + dropRateBump * speedNorm;\n\n    vec2 seed1 = nextParticle.xy + v_textureCoordinates;\n    vec2 seed2 = nextSpeed.rg + v_textureCoordinates;\n    vec2 randomParticle = generateRandomParticle(seed1);\n    float randomNumber = rand(seed2, normalRange);\n\n    if (randomNumber < particleDropRate || particleOutbound(nextParticle)) {\n        fragColor = vec4(randomParticle, 0.0, 1.0); // 1.0 means this is a random particle\n    } else {\n        fragColor = vec4(nextParticle, 0.0, 0.0);\n    }\n}\n`;\n","export const renderParticlesVertexShader = /*glsl*/`#version 300 es\nprecision highp float;\n\nin vec2 st;\nin vec3 normal;\n\nuniform sampler2D previousParticlesPosition;\nuniform sampler2D currentParticlesPosition;\nuniform sampler2D postProcessingPosition;\nuniform sampler2D particlesSpeed;\n\nuniform float frameRateAdjustment;\nuniform float particleHeight;\nuniform float aspect;\nuniform float pixelSize;\nuniform vec2 lineWidth;\nuniform vec2 lineLength;\nuniform vec2 domain;\nuniform bool is3D;\n\n// 添加输出变量传递给片元着色器\nout vec4 speed;\nout float v_segmentPosition;\nout vec2 textureCoordinate;\n\n// 添加结构体定义\nstruct adjacentPoints {\n    vec4 previous;\n    vec4 current;\n    vec4 next;\n};\n\nvec3 convertCoordinate(vec2 lonLat) {\n    // WGS84 (lon, lat, lev) -> ECEF (x, y, z)\n    // read https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates for detail\n\n    // WGS 84 geometric constants\n    float a = 6378137.0; // Semi-major axis\n    float b = 6356752.3142; // Semi-minor axis\n    float e2 = 6.69437999014e-3; // First eccentricity squared\n\n    float latitude = radians(lonLat.y);\n    float longitude = radians(lonLat.x);\n\n    float cosLat = cos(latitude);\n    float sinLat = sin(latitude);\n    float cosLon = cos(longitude);\n    float sinLon = sin(longitude);\n\n    float N_Phi = a / sqrt(1.0 - e2 * sinLat * sinLat);\n    float h = particleHeight; // it should be high enough otherwise the particle may not pass the terrain depth test\n    vec3 cartesian = vec3(0.0);\n    cartesian.x = (N_Phi + h) * cosLat * cosLon;\n    cartesian.y = (N_Phi + h) * cosLat * sinLon;\n    cartesian.z = ((b * b) / (a * a) * N_Phi + h) * sinLat;\n    return cartesian;\n}\n\nvec4 calculateProjectedCoordinate(vec2 lonLat) {\n    if (is3D) {\n        vec3 particlePosition = convertCoordinate(lonLat);\n        // 使用 modelViewProjection 矩阵进行投影变换\n        vec4 projectedPosition = czm_modelViewProjection * vec4(particlePosition, 1.0);\n        return projectedPosition;\n    } else {\n        vec3 position2D = vec3(radians(lonLat.x), radians(lonLat.y), 0.0);\n        return czm_modelViewProjection * vec4(position2D, 1.0);\n    }\n}\n\nvec4 calculateOffsetOnNormalDirection(vec4 pointA, vec4 pointB, float offsetSign, float widthFactor) {\n    vec2 aspectVec2 = vec2(aspect, 1.0);\n    vec2 pointA_XY = (pointA.xy / pointA.w) * aspectVec2;\n    vec2 pointB_XY = (pointB.xy / pointB.w) * aspectVec2;\n\n    // 计算方向向量\n    vec2 direction = normalize(pointB_XY - pointA_XY);\n\n    // 计算法向量\n    vec2 normalVector = vec2(-direction.y, direction.x);\n    normalVector.x = normalVector.x / aspect;\n\n    // 使用 widthFactor 调整宽度\n    float offsetLength = widthFactor * lineWidth.y;\n    normalVector = offsetLength * normalVector;\n\n    vec4 offset = vec4(offsetSign * normalVector, 0.0, 0.0);\n    return offset;\n}\n\nvoid main() {\n    // 翻转 Y 轴坐标\n    vec2 flippedIndex = vec2(st.x, 1.0 - st.y);\n\n    vec2 particleIndex = flippedIndex;\n    speed = texture(particlesSpeed, particleIndex);\n\n    vec2 previousPosition = texture(previousParticlesPosition, particleIndex).rg;\n    vec2 currentPosition = texture(currentParticlesPosition, particleIndex).rg;\n    vec2 nextPosition = texture(postProcessingPosition, particleIndex).rg;\n\n    float isAnyRandomPointUsed = texture(postProcessingPosition, particleIndex).a +\n        texture(currentParticlesPosition, particleIndex).a +\n        texture(previousParticlesPosition, particleIndex).a;\n\n    adjacentPoints projectedCoordinates;\n    if (isAnyRandomPointUsed > 0.0) {\n        projectedCoordinates.previous = calculateProjectedCoordinate(previousPosition);\n        projectedCoordinates.current = projectedCoordinates.previous;\n        projectedCoordinates.next = projectedCoordinates.previous;\n    } else {\n        projectedCoordinates.previous = calculateProjectedCoordinate(previousPosition);\n        projectedCoordinates.current = calculateProjectedCoordinate(currentPosition);\n        projectedCoordinates.next = calculateProjectedCoordinate(nextPosition);\n    }\n\n    int pointToUse = int(normal.x);\n    float offsetSign = normal.y;\n    vec4 offset = vec4(0.0);\n\n    // 计算速度相关的宽度和长度因子\n    float speedLength = clamp(speed.b, domain.x, domain.y);\n    float normalizedSpeed = (speedLength - domain.x) / (domain.y - domain.x);\n    \n    // 根据速度计算宽度\n    float widthFactor = mix(lineWidth.x, lineWidth.y, normalizedSpeed);\n    widthFactor *= (pointToUse < 0 ? 1.0 : 0.5); // 头部更宽，尾部更窄\n\n    // Calculate length based on speed\n    float lengthFactor = mix(lineLength.x, lineLength.y, normalizedSpeed) * pixelSize;\n\n    if (pointToUse == 1) {\n        // 头部位置\n        offset = pixelSize * calculateOffsetOnNormalDirection(\n            projectedCoordinates.previous,\n            projectedCoordinates.current,\n            offsetSign,\n            widthFactor\n        );\n        gl_Position = projectedCoordinates.previous + offset;\n        v_segmentPosition = 0.0; // 头部\n    } else if (pointToUse == -1) {\n        // Get direction and normalize it to length 1.0\n        vec4 direction = normalize(projectedCoordinates.next - projectedCoordinates.current);\n        vec4 extendedPosition = projectedCoordinates.current + direction * lengthFactor;\n\n        offset = pixelSize * calculateOffsetOnNormalDirection(\n            projectedCoordinates.current,\n            extendedPosition,\n            offsetSign,\n            widthFactor\n        );\n        gl_Position = extendedPosition + offset;\n        v_segmentPosition = 1.0; // 尾部\n    }\n\n    textureCoordinate = st;\n}\n`;\n\nexport const renderParticlesFragmentShader = /*glsl*/`#version 300 es\nprecision highp float;\n\nin vec4 speed;\nin float v_segmentPosition;\nin vec2 textureCoordinate;\n\nuniform vec2 domain;\nuniform vec2 displayRange;\nuniform sampler2D colorTable;\nuniform sampler2D segmentsDepthTexture;\n\nout vec4 fragColor;\n\nvoid main() {\n    const float zero = 0.0;\n    if(speed.a > zero && speed.b > displayRange.x && speed.b < displayRange.y) {\n        float speedLength = clamp(speed.b, domain.x, domain.y);\n        float normalizedSpeed = (speedLength - domain.x) / (domain.y - domain.x);\n        vec4 baseColor = texture(colorTable, vec2(normalizedSpeed, zero));\n\n        // 使用更平滑的渐变效果\n        float alpha = smoothstep(0.0, 1.0, v_segmentPosition);\n        alpha = pow(alpha, 1.5); // 调整透明度渐变曲线\n\n        // 根据速度调整透明度\n        float speedAlpha = mix(0.3, 1.0, speed.a);\n\n        // 组合颜色和透明度\n        fragColor = vec4(baseColor.rgb, baseColor.a * alpha * speedAlpha);\n    } else {\n        fragColor = vec4(zero);\n    }\n\n    float segmentsDepth = texture(segmentsDepthTexture, textureCoordinate).r;\n    float globeDepth = czm_unpackDepth(texture(czm_globeDepthTexture, textureCoordinate));\n    if (segmentsDepth < globeDepth) {\n        fragColor = vec4(zero);\n    }\n}\n`;\n","import {\n  Geometry,\n  ShaderProgram,\n  VertexArray,\n  DrawCommand,\n  RenderState,\n  Pass,\n  PrimitiveType,\n  ShaderSource,\n  ClearCommand,\n  Color,\n  defined,\n  ComputeCommand,\n  Matrix4,\n  BufferUsage,\n  defaultValue,\n  destroyObject,\n} from 'cesium';\n\ninterface CustomPrimitiveOptions {\n  isDynamic?: () => boolean;\n  commandType: 'Draw' | 'Compute';\n  geometry?: Geometry;\n  attributeLocations?: { [key: string]: number };\n  primitiveType?: PrimitiveType;\n  uniformMap?: { [key: string]: () => any };\n  vertexShaderSource?: ShaderSource;\n  fragmentShaderSource: ShaderSource;\n  rawRenderState?: any;\n  framebuffer?: any;\n  outputTexture?: any;\n  autoClear?: boolean;\n  preExecute?: () => void;\n}\n\nexport default class CustomPrimitive {\n  commandType: 'Draw' | 'Compute';\n  geometry?: Geometry;\n  attributeLocations?: { [key: string]: number };\n  primitiveType?: PrimitiveType;\n  uniformMap: { [key: string]: () => any };\n  vertexShaderSource?: ShaderSource;\n  fragmentShaderSource: ShaderSource;\n  rawRenderState: any;\n  framebuffer?: any;\n  outputTexture?: any;\n  autoClear: boolean;\n  preExecute?: () => void;\n  show: boolean;\n  commandToExecute?: DrawCommand | ComputeCommand;\n  clearCommand?: ClearCommand;\n  isDynamic: () => boolean;\n\n  constructor(options: CustomPrimitiveOptions) {\n    this.commandType = options.commandType;\n    this.geometry = options.geometry;\n    this.attributeLocations = options.attributeLocations;\n    this.primitiveType = options.primitiveType;\n    this.uniformMap = options.uniformMap || {};\n    this.vertexShaderSource = options.vertexShaderSource;\n    this.fragmentShaderSource = options.fragmentShaderSource;\n    this.rawRenderState = options.rawRenderState;\n    this.framebuffer = options.framebuffer;\n    this.outputTexture = options.outputTexture;\n    this.autoClear = defaultValue(options.autoClear, false)\n    this.preExecute = options.preExecute;\n\n    this.show = true;\n    this.commandToExecute = undefined;\n    this.clearCommand = undefined;\n    this.isDynamic = options.isDynamic ?? (() => true);\n    \n    if (this.autoClear) {\n      this.clearCommand = new ClearCommand({\n        color: new Color(0.0, 0.0, 0.0, 0.0),\n        depth: 1.0,\n        framebuffer: this.framebuffer,\n        pass: Pass.OPAQUE,\n      });\n    }\n  }\n\n  createCommand(context: any): DrawCommand | ComputeCommand {\n    if (this.commandType === 'Draw') {\n      const vertexArray = VertexArray.fromGeometry({\n        context: context,\n        geometry: this.geometry!,\n        attributeLocations: this.attributeLocations,\n        bufferUsage: BufferUsage.STATIC_DRAW,\n      });\n\n      const shaderProgram = ShaderProgram.fromCache({\n        context: context,\n        vertexShaderSource: this.vertexShaderSource!,\n        fragmentShaderSource: this.fragmentShaderSource,\n        attributeLocations: this.attributeLocations,\n      });\n\n      const renderState = RenderState.fromCache(this.rawRenderState);\n      return new DrawCommand({\n        owner: this,\n        vertexArray: vertexArray,\n        primitiveType: this.primitiveType!,\n        modelMatrix: Matrix4.IDENTITY,\n        renderState,\n        shaderProgram: shaderProgram,\n        framebuffer: this.framebuffer,\n        uniformMap: this.uniformMap,\n        pass: Pass.OPAQUE,\n      });\n    } else if (this.commandType === 'Compute') {\n      return new ComputeCommand({\n        owner: this,\n        fragmentShaderSource: this.fragmentShaderSource,\n        uniformMap: this.uniformMap,\n        outputTexture: this.outputTexture,\n        persists: true\n      });\n    } else {\n      throw new Error('Unknown command type');\n    }\n  }\n\n  setGeometry(context: any, geometry: Geometry) {\n    this.geometry = geometry;\n    if (defined(this.commandToExecute)) {\n      this.commandToExecute.vertexArray = VertexArray.fromGeometry({\n        context: context,\n        geometry: this.geometry,\n        attributeLocations: this.attributeLocations!,\n        bufferUsage: BufferUsage.STATIC_DRAW,\n      });\n    }\n  }\n\n  update(frameState: any) {\n    if (!this.isDynamic()) {\n      return;\n    }\n\n    if (!this.show || !defined(frameState)) {\n      return;\n    }\n\n    if (!defined(this.commandToExecute)) {\n      this.commandToExecute = this.createCommand(frameState.context);\n    }\n\n    if (defined(this.preExecute)) {\n      this.preExecute();\n    }\n\n    if (!frameState.commandList) {\n      console.warn('frameState.commandList is undefined');\n      return;\n    }\n\n    if (defined(this.clearCommand)) {\n      frameState.commandList.push(this.clearCommand);\n    }\n\n    if (defined(this.commandToExecute)) {\n      frameState.commandList.push(this.commandToExecute);\n    }\n  }\n\n  isDestroyed(): boolean {\n    return false;\n  }\n\n  destroy() {\n    if (defined(this.commandToExecute)) {\n      this.commandToExecute.shaderProgram?.destroy();\n      this.commandToExecute.shaderProgram = undefined;\n    }\n    return destroyObject(this);\n  }\n}","export function deepMerge<T extends Record<string, any>>(from: Partial<T>, to: T): T {\n  // Handle null or undefined cases\n  if (!from) return to;\n  if (!to) return from as T;\n\n  // Create a new object to avoid modifying the original\n  const result = { ...to };\n\n  for (const key in from) {\n    if (Object.prototype.hasOwnProperty.call(from, key)) {\n      const fromValue = from[key];\n      const toValue = to[key];\n\n      // Handle array case\n      if (Array.isArray(fromValue)) {\n        result[key] = fromValue.slice();\n        continue;\n      }\n\n      // Handle object case\n      if (fromValue && typeof fromValue === 'object') {\n        result[key] = deepMerge(fromValue, toValue || {}) as T[Extract<keyof T, string>];\n        continue;\n      }\n\n      // Handle primitive values\n      if (fromValue !== undefined) {\n        result[key] = fromValue;\n      }\n    }\n  }\n\n  return result;\n}\n","import { Geometry, GeometryAttribute, ComponentDatatype, PrimitiveType, GeometryAttributes, Color, Texture, Sampler, TextureMinificationFilter, TextureMagnificationFilter, PixelFormat, PixelDatatype, Framebuffer, Appearance, SceneMode, TextureWrap, VertexArray, BufferUsage, Cartesian2 } from 'cesium';\nimport { WindLayerOptions } from './types';\nimport { WindParticlesComputing } from './windParticlesComputing';\nimport CustomPrimitive from './customPrimitive';\nimport { ShaderManager } from './shaderManager';\nimport { deepMerge } from './utils';\nimport { DefaultOptions } from '.';\n\nexport class WindParticlesRendering {\n  private context: any;\n  private options: WindLayerOptions;\n  viewerParameters: any;\n  private computing: WindParticlesComputing;\n  public primitives!: ReturnType<typeof this.createPrimitives>;\n  private colorTable: Texture;\n  textures: ReturnType<typeof this.createRenderingTextures>;\n  framebuffers: ReturnType<typeof this.createRenderingFramebuffers>;\n\n  constructor(context: any, options: WindLayerOptions, viewerParameters: any, computing: WindParticlesComputing) {\n    this.context = context;\n    this.options = options;\n    this.viewerParameters = viewerParameters;\n    this.computing = computing;\n\n    if (typeof this.options.particlesTextureSize !== 'number' || this.options.particlesTextureSize <= 0) {\n      console.error('Invalid particlesTextureSize. Using default value of 256.');\n      this.options.particlesTextureSize = 256;\n    }\n\n    this.colorTable = this.createColorTableTexture();\n    this.textures = this.createRenderingTextures();\n    this.framebuffers = this.createRenderingFramebuffers();\n    this.primitives = this.createPrimitives();\n  }\n\n  createRenderingTextures() {\n    const colorTextureOptions = {\n      context: this.context,\n      width: this.context.drawingBufferWidth,\n      height: this.context.drawingBufferHeight,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE\n    };\n    const depthTextureOptions = {\n      context: this.context,\n      width: this.context.drawingBufferWidth,\n      height: this.context.drawingBufferHeight,\n      pixelFormat: PixelFormat.DEPTH_COMPONENT,\n      pixelDatatype: PixelDatatype.UNSIGNED_INT\n    };\n\n    return {\n      segmentsColor: new Texture(colorTextureOptions),\n      segmentsDepth: new Texture(depthTextureOptions)\n    }\n  }\n\n  createRenderingFramebuffers() {\n    return {\n      segments: new Framebuffer({\n        context: this.context,\n        colorTextures: [this.textures.segmentsColor],\n        depthTexture: this.textures.segmentsDepth\n      })\n    }\n  }\n\n  destoryRenderingFramebuffers() {\n    Object.values(this.framebuffers).forEach((framebuffer: any) => {\n      framebuffer.destroy();\n    });\n  }\n\n  private createColorTableTexture(): Texture {\n    const colorTableData = new Float32Array(this.options.colors.flatMap(color => {\n      const cesiumColor = Color.fromCssColorString(color);\n      return [cesiumColor.red, cesiumColor.green, cesiumColor.blue, cesiumColor.alpha];\n    }));\n\n    return new Texture({\n      context: this.context,\n      width: this.options.colors.length,\n      height: 1,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.FLOAT,\n      sampler: new Sampler({\n        minificationFilter: TextureMinificationFilter.LINEAR,\n        magnificationFilter: TextureMagnificationFilter.LINEAR,\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE\n      }),\n      source: {\n        width: this.options.colors.length,\n        height: 1,\n        arrayBufferView: colorTableData\n      }\n    });\n  }\n\n  createSegmentsGeometry(): Geometry {\n    const repeatVertex = 4, texureSize = this.options.particlesTextureSize;\n    // 坐标系\n    //  z\n    //  | /y\n    //  |/\n    //  o------x\n    let st: any = []; // 纹理数组 st坐标系，左下角被定义为(0,0), 右上角为(1,1)，用于传入到顶点着色器中指代粒子的位置\n    for (let s = 0; s < texureSize; s++) {\n      for (let t = 0; t < texureSize; t++) {\n        for (let i = 0; i < repeatVertex; i++) {\n          st.push(s / texureSize);\n          st.push(t / texureSize);\n        }\n      }\n    }\n    st = new Float32Array(st);\n\n    const particlesCount = this.options.particlesTextureSize ** 2;\n\n    let normal: any = [];\n    for (let i = 0; i < particlesCount; i++) {\n      normal.push(\n        // (point to use, offset sign, not used component)\n        -1, -1, 0,\n        -1, 1, 0,\n        1, -1, 0,\n        1, 1, 0\n      )\n    }\n    normal = new Float32Array(normal);\n\n    let vertexIndexes: any = []; // 索引,一个粒子矩形由两个三角形组成\n    for (let i = 0, vertex = 0; i < particlesCount; i++) {\n      vertexIndexes.push(\n        // 第一个三角形用的顶点\n        vertex + 0, vertex + 1, vertex + 2,\n        // 第二个三角形用的顶点\n        vertex + 2, vertex + 1, vertex + 3\n      )\n\n      vertex += repeatVertex;\n    }\n    vertexIndexes = new Uint32Array(vertexIndexes);\n\n    const geometry = new Geometry({\n      attributes: new (GeometryAttributes as any)({\n        st: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.FLOAT,\n          componentsPerAttribute: 2,\n          values: st\n        }),\n        normal: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.FLOAT,\n          componentsPerAttribute: 3,\n          values: normal\n        }),\n      }),\n      indices: vertexIndexes\n    });\n\n    return geometry;\n  }\n\n  private createRawRenderState(options: {\n    viewport?: any;\n    depthTest?: any;\n    depthMask?: any;\n    blending?: any;\n  }): any {\n    return (Appearance as any).getDefaultRenderState(true, false, {\n      viewport: undefined,\n      depthTest: undefined,\n      depthMask: undefined,\n      blending: undefined,\n      ...options\n    });\n  }\n\n  private createPrimitives() {\n    const segments = new CustomPrimitive({\n      commandType: 'Draw',\n      attributeLocations: {\n        st: 0,\n        normal: 1\n      },\n      geometry: this.createSegmentsGeometry(),\n      primitiveType: PrimitiveType.TRIANGLES,\n      uniformMap: {\n        previousParticlesPosition: () => this.computing.particlesTextures.previousParticlesPosition,\n        currentParticlesPosition: () => this.computing.particlesTextures.currentParticlesPosition,\n        postProcessingPosition: () => this.computing.particlesTextures.postProcessingPosition,\n        particlesSpeed: () => this.computing.particlesTextures.particlesSpeed,\n        frameRateAdjustment: () => this.computing.frameRateAdjustment,\n        colorTable: () => this.colorTable,\n        domain: () => {\n          const domain = new Cartesian2(this.options.domain?.min ?? this.computing.windData.speed.min, this.options.domain?.max ?? this.computing.windData.speed.max);\n          return domain;\n        },\n        displayRange: () => {\n          const displayRange = new Cartesian2(\n            this.options.displayRange?.min ?? this.computing.windData.speed.min,\n            this.options.displayRange?.max ?? this.computing.windData.speed.max\n          );\n          return displayRange;\n        },\n        particleHeight: () => this.options.particleHeight || 0,\n        aspect: () => this.context.drawingBufferWidth / this.context.drawingBufferHeight,\n        pixelSize: () => this.viewerParameters.pixelSize,\n        lineWidth: () => {\n          const width = this.options.lineWidth || DefaultOptions.lineWidth;\n          return new Cartesian2(width.min, width.max);\n        },\n        lineLength: () => {\n          const length = this.options.lineLength || DefaultOptions.lineLength;\n          return new Cartesian2(length.min, length.max);\n        },\n        is3D: () => this.viewerParameters.sceneMode === SceneMode.SCENE3D,\n        segmentsDepthTexture: () => this.textures.segmentsDepth,\n      },\n      vertexShaderSource: ShaderManager.getSegmentDrawVertexShader(),\n      fragmentShaderSource: ShaderManager.getSegmentDrawFragmentShader(),\n      rawRenderState: this.createRawRenderState({\n        viewport: undefined,\n        depthTest: {\n          enabled: true\n        },\n        depthMask: true,\n        blending: {\n          enabled: true,\n          blendEquation: WebGLRenderingContext.FUNC_ADD,\n          blendFuncSource: WebGLRenderingContext.SRC_ALPHA,\n          blendFuncDestination: WebGLRenderingContext.ONE_MINUS_SRC_ALPHA\n        }\n      })\n    });\n\n    return { segments };\n  }\n\n  onParticlesTextureSizeChange() {\n    const geometry = this.createSegmentsGeometry();\n    this.primitives.segments.geometry = geometry;\n    const vertexArray = VertexArray.fromGeometry({\n      context: this.context,\n      geometry: geometry,\n      attributeLocations: this.primitives.segments.attributeLocations,\n      bufferUsage: BufferUsage.STATIC_DRAW,\n    });\n    if (this.primitives.segments.commandToExecute) {\n      this.primitives.segments.commandToExecute.vertexArray = vertexArray;\n    }\n  }\n\n  onColorTableChange() {\n    this.colorTable.destroy();\n    this.colorTable = this.createColorTableTexture();\n  }\n\n  updateOptions(options: Partial<WindLayerOptions>) {\n    const needUpdateColorTable = options.colors &&\n      JSON.stringify(options.colors) !== JSON.stringify(this.options.colors);\n\n    // Update options first\n    this.options = deepMerge(options, this.options);\n\n    // Then update color table if needed\n    if (needUpdateColorTable) {\n      this.onColorTableChange();\n    }\n  }\n\n  destroy(): void {\n    Object.values(this.framebuffers).forEach((framebuffer: any) => {\n      framebuffer.destroy();\n    });\n    Object.values(this.primitives).forEach((primitive: any) => {\n      primitive.destroy();\n    });\n    this.colorTable.destroy();\n  }\n}\n","import { WindLayerOptions, WindData } from './types';\nimport { WindParticlesComputing } from './windParticlesComputing';\nimport { WindParticlesRendering } from './windParticlesRendering';\nimport CustomPrimitive from './customPrimitive';\nimport { ClearCommand, Color, Pass } from 'cesium';\nimport { deepMerge } from './utils';\n\nexport class WindParticleSystem {\n  computing: WindParticlesComputing;\n  rendering: WindParticlesRendering;\n  options: WindLayerOptions;\n  viewerParameters: any;\n  context: any;\n  constructor(context: any, windData: Required<WindData>, options: WindLayerOptions, viewerParameters: any, scene: any) {\n    this.context = context;\n    this.options = options;\n    this.viewerParameters = viewerParameters;\n    this.computing = new WindParticlesComputing(context, windData, options, viewerParameters, scene);\n    this.rendering = new WindParticlesRendering(context, options, viewerParameters, this.computing);\n    this.clearFramebuffers();\n  }\n\n  getPrimitives(): CustomPrimitive[] {\n    const primitives = [\n      this.computing.primitives.calculateSpeed,\n      this.computing.primitives.updatePosition,\n      this.computing.primitives.postProcessingPosition,\n      this.rendering.primitives.segments,\n    ];\n\n    return primitives;\n  }\n\n  clearFramebuffers() {\n    const clearCommand = new ClearCommand({\n      color: new Color(0.0, 0.0, 0.0, 0.0),\n      depth: 1.0,\n      framebuffer: undefined,\n      pass: Pass.OPAQUE\n    });\n\n    Object.keys(this.rendering.framebuffers).forEach((key) => {\n      clearCommand.framebuffer = this.rendering.framebuffers[key as keyof typeof this.rendering.framebuffers];\n      clearCommand.execute(this.context);\n    });\n  }\n\n  changeOptions(options: Partial<WindLayerOptions>) {\n    let maxParticlesChanged = false;\n    if (options.particlesTextureSize && this.options.particlesTextureSize !== options.particlesTextureSize) {\n      maxParticlesChanged = true;\n    }\n\n    const newOptions = deepMerge(options, this.options);\n    if (newOptions.particlesTextureSize < 1) {\n      throw new Error('particlesTextureSize must be greater than 0');\n    }\n    this.options = newOptions;\n\n    this.rendering.updateOptions(options);\n    this.computing.updateOptions(options);\n    if (maxParticlesChanged) {\n      this.computing.destroyParticlesTextures();\n      this.computing.createParticlesTextures();\n      this.rendering.onParticlesTextureSizeChange();\n    }\n  }\n\n  applyViewerParameters(viewerParameters: any): void {\n    this.viewerParameters = viewerParameters;\n    this.computing.viewerParameters = viewerParameters;\n    this.rendering.viewerParameters = viewerParameters;\n  }\n\n  destroy(): void {\n    this.computing.destroy();\n    this.rendering.destroy();\n  }\n}"],"mappings":";;;;;AAAA;AAAA,EAGE,cAAAA;AAAA,EAEA,QAAQ;AAAA,EACR;AAAA,OACK;;;ACPP,SAAS,eAAe,aAAa,SAAS,SAAS,4BAA4B,2BAA2B,YAAY,wBAAwB;;;ACAlJ,SAAS,oBAAoB;;;ACAtB,IAAM;AAAA;AAAA,EAA+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACArC,IAAM;AAAA;AAAA,EAA+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACArC,IAAM;AAAA;AAAA,EAA+C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACArD,IAAM;AAAA;AAAA,EAAsC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgK5C,IAAM;AAAA;AAAA,EAAwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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","names":["Cartesian2","Geometry","PrimitiveType","Color","Texture","Sampler","TextureMinificationFilter","TextureMagnificationFilter","PixelFormat","PixelDatatype","VertexArray","BufferUsage","Cartesian2","PixelFormat","PixelDatatype","Texture","Color","Sampler","TextureMinificationFilter","TextureMagnificationFilter","Geometry","PrimitiveType","Cartesian2","VertexArray","BufferUsage","ClearCommand","Color","Pass","ClearCommand","Color","Pass","Cartesian2"]}