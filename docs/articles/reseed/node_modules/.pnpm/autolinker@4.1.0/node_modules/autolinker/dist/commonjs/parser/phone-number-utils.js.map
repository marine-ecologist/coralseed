{"version":3,"file":"phone-number-utils.js","sourceRoot":"","sources":["../../../src/parser/phone-number-utils.ts"],"names":[],"mappings":";;AA0BA,gEAEC;AASD,4DAEC;AASD,gDAaC;AA7DD,8EAA8E;AAC9E,IAAM,eAAe,GAAG,OAAO,CAAC;AAEhC,gFAAgF;AAChF,8EAA8E;AAC9E,IAAM,eAAe,GAAG,SAAS,CAAC;AAElC,mCAAmC;AACnC,IAAM,aAAa,GAAG,MAAM,CAAC;AAE7B,gFAAgF;AAChF,6DAA6D;AAC7D,IAAM,gBAAgB,GAClB,uQAAuQ,CAAC;AAE5Q,mCAAmC;AACnC,IAAM,eAAe,GACjB,iIAAiI,CAAC;AAEtI,iBAAiB;AACjB,IAAM,kBAAkB,GAAG,IAAI,MAAM,CAAC,WAAI,gBAAgB,CAAC,MAAM,cAAI,eAAe,CAAC,MAAM,MAAG,CAAC,CAAC;AAEhG;;;GAGG;AACH,SAAgB,0BAA0B,CAAC,IAAY;IACnD,OAAO,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACtC,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,wBAAwB,CAAC,IAAY;IACjD,OAAO,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACpC,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,kBAAkB,CAAC,eAAuB;IACtD,2EAA2E;IAC3E,iEAAiE;IACjE,EAAE;IACF,WAAW;IACX,qBAAqB;IACrB,mBAAmB;IACnB,mBAAmB;IACnB,+FAA+F;IAC/F,IAAM,aAAa,GACf,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,eAAe,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;IAE/E,OAAO,aAAa,IAAI,kBAAkB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;AACrE,CAAC","sourcesContent":["// Regex that holds the characters used to separate segments of a phone number\nconst separatorCharRe = /[-. ]/;\n\n// Regex that specifies any delimiter char that allows us to treat the number as\n// a phone number rather than just any other number that could appear in text.\nconst hasDelimCharsRe = /[-. ()]/;\n\n// \"Pause\" and \"Wait\" control chars\nconst controlCharRe = /[,;]/;\n\n// Over the years, many people have added to this regex, but it should have been\n// split up by country. Maybe one day we can break this down.\nconst mostPhoneNumbers =\n    /(?:(?:(?:(\\+)?\\d{1,3}[-. ]?)?\\(?\\d{3}\\)?[-. ]?\\d{3}[-. ]?\\d{4})|(?:(\\+)(?:9[976]\\d|8[987530]\\d|6[987]\\d|5[90]\\d|42\\d|3[875]\\d|2[98654321]\\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)[-. ]?(?:\\d[-. ]?){6,12}\\d+))([,;]+[0-9]+#?)*/;\n\n// Regex for Japanese phone numbers\nconst japanesePhoneRe =\n    /(0([1-9]-?[1-9]\\d{3}|[1-9]{2}-?\\d{3}|[1-9]{2}\\d{1}-?\\d{2}|[1-9]{2}\\d{2}-?\\d{1})-?\\d{4}|0[789]0-?\\d{4}-?\\d{4}|050-?\\d{4}-?\\d{4})/;\n\n// Combined regex\nconst validPhoneNumberRe = new RegExp(`^${mostPhoneNumbers.source}|${japanesePhoneRe.source}$`);\n\n/**\n * Determines if the character is a phone number separator character (i.e.\n * '-', '.', or ' ' (space))\n */\nexport function isPhoneNumberSeparatorChar(char: string): boolean {\n    return separatorCharRe.test(char);\n}\n\n/**\n * Determines if the character is a control character in a phone number. Control\n * characters are as follows:\n *\n * - ',': A 1 second pause. Useful for dialing extensions once the main phone number has been reached\n * - ';': A \"wait\" that waits for the user to take action (tap something, for instance on a smart phone)\n */\nexport function isPhoneNumberControlChar(char: string): boolean {\n    return controlCharRe.test(char);\n}\n\n/**\n * Determines if the given phone number text found in a string is a valid phone\n * number.\n *\n * Our state machine parser is simplified to grab anything that looks like a\n * phone number, and this function confirms the match.\n */\nexport function isValidPhoneNumber(phoneNumberText: string): boolean {\n    // We'll only consider the match as a phone number if there is some kind of\n    // delimiter character (a prefixed '+' sign, or separator chars).\n    //\n    // Accepts:\n    //     (123) 456-7890\n    //     +38755233976\n    // Does not accept:\n    //     1234567890  (no delimiter chars - may just be a random number that's not a phone number)\n    const hasDelimiters =\n        phoneNumberText.charAt(0) === '+' || hasDelimCharsRe.test(phoneNumberText);\n\n    return hasDelimiters && validPhoneNumberRe.test(phoneNumberText);\n}\n"]}