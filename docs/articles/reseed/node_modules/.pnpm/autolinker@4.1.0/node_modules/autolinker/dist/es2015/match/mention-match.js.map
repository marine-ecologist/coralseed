{"version":3,"file":"mention-match.js","sourceRoot":"","sources":["../../../src/match/mention-match.ts"],"names":[],"mappings":";AACA,OAAO,EAAE,WAAW,EAAE,MAAM,UAAU,CAAC;AACvC,OAAO,EAAE,aAAa,EAAuB,MAAM,kBAAkB,CAAC;AAEtE;;;;;;;GAOG;AACH;IAAkC,gCAAa;IA0B3C;;;;OAIG;IACH,sBAAY,GAAuB;QAC/B,YAAA,MAAK,YAAC,GAAG,CAAC,SAAC;QA/Bf;;;;;;;WAOG;QACa,UAAI,GAAc,SAAS,CAAC;QAE5C;;;;;WAKG;QACc,iBAAW,GAAmB,SAAS,CAAC,CAAC,gGAAgG;QAE1J;;;;WAIG;QACc,aAAO,GAAW,EAAE,CAAC,CAAC,gGAAgG;QAUnI,KAAI,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC;QAC3B,KAAI,CAAC,WAAW,GAAG,GAAG,CAAC,WAAW,CAAC;;IACvC,CAAC;IAED;;;;;OAKG;IACH,8BAAO,GAAP;QACI,OAAO,SAAS,CAAC;IACrB,CAAC;IAED;;;;OAIG;IACH,iCAAU,GAAV;QACI,OAAO,IAAI,CAAC,OAAO,CAAC;IACxB,CAAC;IAED;;;;;OAKG;IACH,qCAAc,GAAd;QACI,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED;;;;OAIG;IACH,oCAAa,GAAb;QACI,QAAQ,IAAI,CAAC,WAAW,EAAE,CAAC;YACvB,KAAK,SAAS;gBACV,OAAO,sBAAsB,GAAG,IAAI,CAAC,OAAO,CAAC;YACjD,KAAK,WAAW;gBACZ,OAAO,wBAAwB,GAAG,IAAI,CAAC,OAAO,CAAC;YACnD,KAAK,YAAY;gBACb,OAAO,yBAAyB,GAAG,IAAI,CAAC,OAAO,CAAC;YACpD,KAAK,QAAQ;gBACT,OAAO,0BAA0B,GAAG,IAAI,CAAC,OAAO,CAAC;YACrD,KAAK,SAAS;gBACV,OAAO,uBAAuB,GAAG,IAAI,CAAC,OAAO,CAAC;YAElD;gBACI,uGAAuG;gBACvG,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBAC9B,MAAM,IAAI,KAAK,CAAC,4CAA4C,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC;QACzF,CAAC;IACL,CAAC;IAED;;;;OAIG;IACH,oCAAa,GAAb;QACI,OAAO,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC;IAC9B,CAAC;IAED;;;;;;OAMG;IACH,0CAAmB,GAAnB;QACI,IAAI,gBAAgB,GAAG,gBAAK,CAAC,mBAAmB,WAAE,EAC9C,WAAW,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QAExC,IAAI,WAAW,EAAE,CAAC;YACd,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACvC,CAAC;QACD,OAAO,gBAAgB,CAAC;IAC5B,CAAC;IACL,mBAAC;AAAD,CAAC,AArHD,CAAkC,aAAa,GAqH9C","sourcesContent":["import { MentionService } from '../parser/mention-utils';\nimport { assertNever } from '../utils';\nimport { AbstractMatch, AbstractMatchConfig } from './abstract-match';\n\n/**\n * @class Autolinker.match.Mention\n * @extends Autolinker.match.AbstractMatch\n *\n * Represents a Mention match found in an input string which should be Autolinked.\n *\n * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n */\nexport class MentionMatch extends AbstractMatch {\n    /**\n     * @public\n     * @property {'mention'} type\n     *\n     * A string name for the type of match that this class represents. Can be\n     * used in a TypeScript discriminating union to type-narrow from the\n     * `Match` type.\n     */\n    public readonly type: 'mention' = 'mention';\n\n    /**\n     * @cfg {String} serviceName\n     *\n     * The service to point mention matches to. See {@link Autolinker#mention}\n     * for available values.\n     */\n    private readonly serviceName: MentionService = 'twitter'; // default value just to get the above doc comment in the ES5 output and documentation generator\n\n    /**\n     * @cfg {String} mention (required)\n     *\n     * The Mention that was matched, without the '@' character.\n     */\n    private readonly mention: string = ''; // default value just to get the above doc comment in the ES5 output and documentation generator\n\n    /**\n     * @method constructor\n     * @param {Object} cfg The configuration properties for the Match\n     *   instance, specified in an Object (map).\n     */\n    constructor(cfg: MentionMatchConfig) {\n        super(cfg);\n\n        this.mention = cfg.mention;\n        this.serviceName = cfg.serviceName;\n    }\n\n    /**\n     * Returns a string name for the type of match that this class represents.\n     * For the case of MentionMatch, returns 'mention'.\n     *\n     * @return {String}\n     */\n    getType(): 'mention' {\n        return 'mention';\n    }\n\n    /**\n     * Returns the mention, without the '@' character.\n     *\n     * @return {String}\n     */\n    getMention(): string {\n        return this.mention;\n    }\n\n    /**\n     * Returns the configured {@link #serviceName} to point the mention to.\n     * Ex: 'instagram', 'twitter', 'soundcloud'.\n     *\n     * @return {String}\n     */\n    getServiceName(): MentionService {\n        return this.serviceName;\n    }\n\n    /**\n     * Returns the anchor href that should be generated for the match.\n     *\n     * @return {String}\n     */\n    getAnchorHref(): string {\n        switch (this.serviceName) {\n            case 'twitter':\n                return 'https://twitter.com/' + this.mention;\n            case 'instagram':\n                return 'https://instagram.com/' + this.mention;\n            case 'soundcloud':\n                return 'https://soundcloud.com/' + this.mention;\n            case 'tiktok':\n                return 'https://www.tiktok.com/@' + this.mention;\n            case 'youtube':\n                return 'https://youtube.com/@' + this.mention;\n\n            default:\n                // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.\n                assertNever(this.serviceName);\n                throw new Error('Unknown service name to point mention to: ' + this.serviceName);\n        }\n    }\n\n    /**\n     * Returns the anchor text that should be generated for the match.\n     *\n     * @return {String}\n     */\n    getAnchorText(): string {\n        return '@' + this.mention;\n    }\n\n    /**\n     * Returns the CSS class suffixes that should be used on a tag built with\n     * the match. See {@link Autolinker.match.Match#getCssClassSuffixes} for\n     * details.\n     *\n     * @return {String[]}\n     */\n    getCssClassSuffixes(): string[] {\n        let cssClassSuffixes = super.getCssClassSuffixes(),\n            serviceName = this.getServiceName();\n\n        if (serviceName) {\n            cssClassSuffixes.push(serviceName);\n        }\n        return cssClassSuffixes;\n    }\n}\n\nexport interface MentionMatchConfig extends AbstractMatchConfig {\n    serviceName: MentionService;\n    mention: string;\n}\n"]}